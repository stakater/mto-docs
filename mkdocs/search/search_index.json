{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"argocd-multitenancy.html","title":"ArgoCD Multi-tenancy","text":"<p>ArgoCD is a declarative GitOps tool built to deploy applications to Kubernetes. While the continuous delivery (CD) space is seen by some as crowded these days, ArgoCD does bring some interesting capabilities to the table. Unlike other tools, ArgoCD is lightweight and easy to configure.</p>"},{"location":"argocd-multitenancy.html#why-argocd","title":"Why ArgoCD?","text":"<p>Application definitions, configurations, and environments should be declarative and version controlled. Application deployment and lifecycle management should be automated, auditable, and easy to understand.</p>"},{"location":"argocd-multitenancy.html#argocd-integration-in-multi-tenant-operator","title":"ArgoCD integration in Multi Tenant Operator","text":"<p>With Multi Tenant Operator (MTO), cluster admins can configure multi tenancy in their cluster. Now with ArgoCD integration, multi tenancy can be configured in ArgoCD applications and AppProjects.</p> <p>MTO (if configured to) will create AppProjects for each tenant. The AppProject will allow tenants to create ArgoCD Applications that can be synced to namespaces owned by those tenants. Cluster admins will also be able to blacklist certain namespaces resources if they want, and allow certain cluster scoped resources as well (see the <code>NamespaceResourceBlacklist</code> and <code>ClusterResourceWhitelist</code> sections in Integration Config docs and Tenant Custom Resource docs).</p> <p>Note that ArgoCD integration in MTO is completely optional.</p>"},{"location":"argocd-multitenancy.html#default-argocd-configuration","title":"Default ArgoCD configuration","text":"<p>We have set a default ArgoCD configuration in Multi Tenant Operator that fulfils the following use cases:</p> <ul> <li>Tenants are able to see only their ArgoCD applications in the ArgoCD frontend</li> <li>Tenant 'Owners' and 'Editors' will have full access to their ArgoCD applications</li> <li>Tenants in the 'Viewers' group will have read-only access to their ArgoCD applications</li> <li>Tenants can sync all namespace-scoped resources, except those that are blacklisted in the spec</li> <li>Tenants can only sync cluster-scoped resources that are whitelisted in the spec</li> <li>Tenant 'Owners' can configure their own GitOps source repos at a tenant level</li> <li>Cluster admins can prevent specific resources from syncing via ArgoCD</li> <li>Cluster admins have full access to all ArgoCD applications and AppProjects</li> <li>Since ArgoCD integration is on a per-tenant level, namespace-scoped applications are only synced to Tenant's namespaces</li> </ul> <p>Detailed use cases showing how to create AppProjects are mentioned in use cases for ArgoCD.</p>"},{"location":"changelog.html","title":"Changelog","text":""},{"location":"changelog.html#v09x","title":"v0.9.x","text":""},{"location":"changelog.html#v091","title":"v0.9.1","text":"<ul> <li>fix: Allow namespace controller to reconcile without crashing, if no IC exists</li> <li>fix: In case a group mentioned in IC doesn't exist, it won't block reconciliation or editing of MTO's manifests</li> </ul>"},{"location":"changelog.html#v090","title":"v0.9.0","text":"<ul> <li>feat: Added console for tenants, templates and integration config</li> <li>feat: Added support for custom realm name for RHSSO integration in Integration Config</li> <li>feat: Add multiple status conditions to tenant and TGI for success and failure cases</li> <li>feat: Show error messages with tenant and TGI status</li> <li>fix: Stop reconciliation breaking for tenant and TGI, instead continue and show warnings</li> <li>fix: Disable TGI/TI reconcile if mentioned template is not found.</li> <li>fix: Disable repeated users webhook in tenant</li> <li>enhance: Reduced API calls</li> <li>enhance: General enhancements and improvements</li> <li>chore: Update dependencies</li> </ul>"},{"location":"changelog.html#enabling-console","title":"Enabling console","text":"<ul> <li>To enable console visit Installation, and add config to subscription for OperatorHub based installation.</li> </ul>"},{"location":"changelog.html#v08x","title":"v0.8.x","text":""},{"location":"changelog.html#v083","title":"v0.8.3","text":"<ul> <li>fix: Reconcile namespaces when the group spec for tenants is changed, so new rolebindings can be created for them</li> </ul>"},{"location":"changelog.html#v081","title":"v0.8.1","text":"<ul> <li>fix: Updated release pipelines</li> </ul>"},{"location":"changelog.html#v080","title":"v0.8.0","text":"<ul> <li>feat: Allow custom roles for each tenant via label selector, more details in custom roles document<ul> <li>Roles mapping is a required field in MTO's IntegrationConfig. By default, it will always be filled with OpenShift's admin/edit/view roles</li> <li>Ensure that mentioned roles exist within the cluster</li> <li>Remove coupling with OpenShift's built-in admin/edit/view roles</li> </ul> </li> <li>feat: Removed coupling of ResourceSupervisor and Tenant resources<ul> <li>Added list of namespaces to hibernate within the ResourceSupervisor resource</li> <li>Ensured that the same namespace cannot be added to two different Resource Supervisors</li> <li>Moved ResourceSupervisor into a separate pod</li> <li>Improved logs</li> </ul> </li> <li>fix: Remove bug from tenant's common and specific metadata</li> <li>fix: Add missing field to Tenant's conversion webhook</li> <li>fix: Fix panic in ResourceSupervisor sleep functionality due to sending on closed channel</li> <li>chore: Update dependencies</li> </ul>"},{"location":"changelog.html#v07x","title":"v0.7.x","text":""},{"location":"changelog.html#v074","title":"v0.7.4","text":"<ul> <li>maintain: Automate certification of new MTO releases on RedHat's Operator Hub</li> </ul>"},{"location":"changelog.html#v073","title":"v0.7.3","text":"<ul> <li>feat: Updated Tenant CR to provide Tenant level AppProject permissions</li> </ul>"},{"location":"changelog.html#v072","title":"v0.7.2","text":"<ul> <li>feat: Add support to map secrets/configmaps from one namespace to other namespaces using TI. Secrets/configmaps will only be mapped if their namespaces belong to same Tenant</li> </ul>"},{"location":"changelog.html#v071","title":"v0.7.1","text":"<ul> <li>feat: Add option to keep AppProjects created by Multi Tenant Operator in case Tenant is deleted. By default, AppProjects get deleted</li> <li>fix: Status now updates after namespaces are created</li> <li>maintain: Changes to Helm chart's default behaviour</li> </ul>"},{"location":"changelog.html#v070","title":"v0.7.0","text":"<ul> <li>feat: Add support to map secrets/configmaps from one namespace to other namespaces using TGI. Resources can be mapped from one Tenant's namespaces to some other Tenant's namespaces</li> <li>feat: Allow creation of sandboxes that are private to the user</li> <li>feat: Allow creation of namespaces without tenant prefix from within tenant spec</li> <li>fix: Webhook changes will now be updated without manual intervention</li> <li>maintain: Updated Tenant CR version from v1beta1 to v1beta2. Conversion webhook is added to facilitate transition to new version<ul> <li>see Tenant spec for updated spec</li> </ul> </li> <li>enhance: Better automated testing</li> </ul>"},{"location":"changelog.html#v06x","title":"v0.6.x","text":""},{"location":"changelog.html#v061","title":"v0.6.1","text":"<ul> <li>fix: Update MTO service-account name in environment variable</li> </ul>"},{"location":"changelog.html#v060","title":"v0.6.0","text":"<ul> <li>feat: Add support to ArgoCD AppProjects created by Tenant Controller to have their sync disabled when relevant namespaces are hibernating</li> <li>feat: Add validation webhook for ResourceSupervisor</li> <li>fix: Delete ResourceSupervisor when hibernation is removed from tenant CR</li> <li>fix: CRQ and limit range not updating when quota changes</li> <li>fix: ArgoCD AppProjects created by Tenant Controller not updating when Tenant label is added to an existing namespace</li> <li>fix: Namespace workflow for TGI</li> <li>fix: ResourceSupervisor deletion workflow</li> <li>fix: Update RHSSO user filter for Vault integration</li> <li>fix: Update regex of namespace names in tenant CRD</li> <li>enhance: Optimize TGI and TI performance under load</li> <li>maintain: Bump Operator-SDK and Dependencies version</li> </ul>"},{"location":"changelog.html#v05x","title":"v0.5.x","text":""},{"location":"changelog.html#v054","title":"v0.5.4","text":"<ul> <li>fix: Update Helm dependency to v3.8.2</li> </ul>"},{"location":"changelog.html#v053","title":"v0.5.3","text":"<ul> <li>fix: Add support for parameters in Helm chartRepository in templates</li> </ul>"},{"location":"changelog.html#v052","title":"v0.5.2","text":"<ul> <li>fix: Add service name prefix for webhooks</li> </ul>"},{"location":"changelog.html#v051","title":"v0.5.1","text":"<ul> <li>fix: ResourceSupervisor CR no longer requires a field for the Tenant name</li> </ul>"},{"location":"changelog.html#v050","title":"v0.5.0","text":"<ul> <li>feat: Add support for tenant namespaces off-boarding. For more details check out onDelete</li> <li> <p>feat: Add tenant webhook for spec validation</p> </li> <li> <p>fix: TemplateGroupInstance now cleans up leftover Template resources from namespaces that are no longer part of TGI namespace selector</p> </li> <li> <p>fix: Fixed hibernation sync issue</p> </li> <li> <p>enhance: Update tenant spec for applying common/specific namespace labels/annotations. For more details check out commonMetadata &amp; SpecificMetadata</p> </li> <li> <p>enhance: Add support for multi-pod architecture for Operator-Hub</p> </li> <li> <p>chore: Remove conversion webhook for Quota and Tenant</p> </li> </ul>"},{"location":"changelog.html#v04x","title":"v0.4.x","text":""},{"location":"changelog.html#v047","title":"v0.4.7","text":"<ul> <li>feat: Add hibernation of StatefulSets and Deployments based on a timer</li> <li>feat: New custom resource that handles hibernation</li> </ul>"},{"location":"changelog.html#v046","title":"v0.4.6","text":"<ul> <li>fix: Revert v0.4.4</li> </ul>"},{"location":"changelog.html#v045","title":"v0.4.5","text":"<ul> <li>feat: Add support for applying labels/annotation on specific namespaces</li> </ul>"},{"location":"changelog.html#v044","title":"v0.4.4","text":"<ul> <li>fix: Update <code>privilegedNamespaces</code> regex</li> </ul>"},{"location":"changelog.html#v043","title":"v0.4.3","text":"<ul> <li>fix: IntegrationConfig will now be synced in all pods</li> </ul>"},{"location":"changelog.html#v042","title":"v0.4.2","text":"<ul> <li>feat: Added support to distribute common labels and annotations to tenant namespaces</li> </ul>"},{"location":"changelog.html#v041","title":"v0.4.1","text":"<ul> <li>fix: Update dependencies to latest version</li> </ul>"},{"location":"changelog.html#v040","title":"v0.4.0","text":"<ul> <li>feat: Controllers are now separated into individual pods</li> </ul>"},{"location":"changelog.html#v03x","title":"v0.3.x","text":""},{"location":"changelog.html#v0333","title":"v0.3.33","text":"<ul> <li>fix: Optimize namespace reconciliation</li> </ul>"},{"location":"changelog.html#v0333_1","title":"v0.3.33","text":"<ul> <li>fix: Revert v0.3.29 change till webhook network issue isn't resolved</li> </ul>"},{"location":"changelog.html#v0333_2","title":"v0.3.33","text":"<ul> <li>fix: Execute webhook and controller of matching custom resource in same pod</li> </ul>"},{"location":"changelog.html#v0330","title":"v0.3.30","text":"<ul> <li>feat: Namespace controller will now trigger TemplateGroupInstance when a new matching namespace is created</li> </ul>"},{"location":"changelog.html#v0329","title":"v0.3.29","text":"<ul> <li>feat: Controllers are now separated into individual pods</li> </ul>"},{"location":"changelog.html#v0328","title":"v0.3.28","text":"<ul> <li>fix: Enhancement of TemplateGroupInstance Namespace event listener</li> </ul>"},{"location":"changelog.html#v0327","title":"v0.3.27","text":"<ul> <li>feat: TemplateGroupInstance will create resources instantly whenever a Namespace with matching labels is created</li> </ul>"},{"location":"changelog.html#v0326","title":"v0.3.26","text":"<ul> <li>fix: Update reconciliation frequency of TemplateGroupInstance</li> </ul>"},{"location":"changelog.html#v0325","title":"v0.3.25","text":"<ul> <li>feat: TemplateGroupInstance will now directly create template resources instead of creating TemplateInstances</li> </ul>"},{"location":"changelog.html#migrating-from-pervious-version","title":"Migrating from pervious version","text":"<ul> <li>To migrate to Tenant-Operator:v0.3.25 perform the following steps<ul> <li>Downscale Tenant-Operator deployment by setting the replicas count to 0</li> <li>Delete TemplateInstances created by TemplateGroupInstance (Naming convention of TemplateInstance created by TemplateGroupInstance is <code>group-{Template.Name}</code>)</li> <li>Update version of Tenant-Operator to v0.3.25 and set the replicas count to 2. After Tenant-Operator pods are up TemplateGroupInstance will create the missing resources</li> </ul> </li> </ul>"},{"location":"changelog.html#v0324","title":"v0.3.24","text":"<ul> <li>feat: Add feature to allow ArgoCD to sync specific cluster scoped custom resources, configurable via Integration Config. More details in relevant docs</li> </ul>"},{"location":"changelog.html#v0323","title":"v0.3.23","text":"<ul> <li>feat: Added concurrent reconcilers for template instance controller</li> </ul>"},{"location":"changelog.html#v0322","title":"v0.3.22","text":"<ul> <li>feat: Added validation webhook to prevent Tenant owners from creating RoleBindings with kind 'Group' or 'User'</li> <li>fix: Removed redundant logs for namespace webhook</li> <li>fix: Added missing check for users in a tenant owner's groups in namespace validation webhook</li> <li>fix: General enhancements and improvements</li> </ul> <p>\u26a0\ufe0f Known Issues</p> <ul> <li><code>caBundle</code> field in validation webhooks is not being populated for newly added webhooks. A temporary fix is to edit the validation webhook configuration manifest without the <code>caBundle</code> field added in any webhook, so OpenShift can add it to all fields simultaneously<ul> <li>Edit the <code>ValidatingWebhookConfiguration</code> <code>stakater-tenant-operator-validating-webhook-configuration</code> by removing all the <code>caBundle</code> fields of all webhooks</li> <li>Save the manifest</li> <li>Verify that all <code>caBundle</code> fields have been populated</li> <li>Restart Tenant-Operator pods</li> </ul> </li> </ul>"},{"location":"changelog.html#v0321","title":"v0.3.21","text":"<ul> <li>feat: Added ClusterRole manager rules extension</li> </ul>"},{"location":"changelog.html#v0320","title":"v0.3.20","text":"<ul> <li>fix: Fixed the recreation of underlying template resources, if resources were deleted</li> </ul>"},{"location":"changelog.html#v0319","title":"v0.3.19","text":"<ul> <li>feat: Namespace webhook FailurePolicy is now set to Ignore instead of Fail</li> <li>fix: Fixed config not being updated in namespace webhook when Integration Config is updated</li> <li>fix: Fixed a crash that occurred in case of ArgoCD in Integration Config was not set during deletion of Tenant resource</li> </ul> <p>\u26a0\ufe0f ApiVersion <code>v1alpha1</code> of Tenant and Quota custom resources has been deprecated and is scheduled to be removed in the future. The following links contain the updated structure of both resources</p> <ul> <li>Quota v1beta1</li> <li>Tenant v1beta1</li> </ul>"},{"location":"changelog.html#v0318","title":"v0.3.18","text":"<ul> <li>fix: Add ArgoCD namespace to destination namespaces for App Projects</li> </ul>"},{"location":"changelog.html#v0317","title":"v0.3.17","text":"<ul> <li>fix: Cluster administrator's permission will now have higher precedence on privileged namespaces</li> </ul>"},{"location":"changelog.html#v0316","title":"v0.3.16","text":"<ul> <li>fix: Add groups mentioned in Tenant CR to ArgoCD App Project manifests' RBAC</li> </ul>"},{"location":"changelog.html#v0315","title":"v0.3.15","text":"<ul> <li>feat: Add validation webhook for TemplateInstance &amp; TemplateGroupInstance to prevent their creation in case the Template they reference does not exist</li> </ul>"},{"location":"changelog.html#v0314","title":"v0.3.14","text":"<ul> <li>feat: Added Validation Webhook for Quota to prevent its deletion when a reference to it exists in any Tenant</li> <li>feat: Added Validation Webhook for Template to prevent its deletion when a reference to it exists in any Tenant, TemplateGroupInstance or TemplateInstance</li> <li>fix: Fixed a crash that occurred in case Integration Config was not found</li> </ul>"},{"location":"changelog.html#v0313","title":"v0.3.13","text":"<ul> <li>feat: Multi Tenant Operator will now consider all namespaces to be managed if any default Integration Config is not found</li> </ul>"},{"location":"changelog.html#v0312","title":"v0.3.12","text":"<ul> <li>fix: General enhancements and improvements</li> </ul>"},{"location":"changelog.html#v0311","title":"v0.3.11","text":"<ul> <li>fix: Fix Quota's conversion webhook converting the wrong LimitRange field</li> </ul>"},{"location":"changelog.html#v0310","title":"v0.3.10","text":"<ul> <li>fix: Fix Quota's LimitRange to its intended design by being an optional field</li> </ul>"},{"location":"changelog.html#v039","title":"v0.3.9","text":"<ul> <li>feat: Add ability to prevent certain resources from syncing via ArgoCD</li> </ul>"},{"location":"changelog.html#v038","title":"v0.3.8","text":"<ul> <li>feat: Add default annotation to OpenShift Projects that show description about the Project</li> </ul>"},{"location":"changelog.html#v037","title":"v0.3.7","text":"<ul> <li>fix: Fix a typo in Multi Tenant Operator's Helm release</li> </ul>"},{"location":"changelog.html#v036","title":"v0.3.6","text":"<ul> <li>fix: Fix ArgoCD's <code>destinationNamespaces</code> created by Multi Tenant Operator</li> </ul>"},{"location":"changelog.html#v035","title":"v0.3.5","text":"<ul> <li>fix: Change sandbox creation from 1 for each group to 1 for each user in a group</li> </ul>"},{"location":"changelog.html#v034","title":"v0.3.4","text":"<ul> <li>feat: Support creation of sandboxes for each group</li> </ul>"},{"location":"changelog.html#v033","title":"v0.3.3","text":"<ul> <li>feat: Add ability to create namespaces from a list of namespace prefixes listed in the Tenant CR</li> </ul>"},{"location":"changelog.html#v032","title":"v0.3.2","text":"<ul> <li>refactor: Restructure Quota CR, more details in relevant docs</li> <li>feat: Add support for adding LimitRanges in Quota</li> <li>feat: Add conversion webhook to convert existing v1alpha1 versions of quota to v1beta1</li> </ul>"},{"location":"changelog.html#v031","title":"v0.3.1","text":"<ul> <li>feat: Add ability to create ArgoCD AppProjects per tenant, more details in relevant docs</li> </ul>"},{"location":"changelog.html#v030","title":"v0.3.0","text":"<ul> <li>feat: Add support to add groups in addition to users as tenant members</li> </ul>"},{"location":"changelog.html#v02x","title":"v0.2.x","text":""},{"location":"changelog.html#v0233","title":"v0.2.33","text":"<ul> <li>refactor: Restructure Tenant spec, more details in relevant docs</li> <li>feat: Add conversion webhook to convert existing v1alpha1 versions of tenant to v1beta1</li> </ul>"},{"location":"changelog.html#v0232","title":"v0.2.32","text":"<ul> <li>refactor: Restructure integration config spec, more details in relevant docs</li> <li>feat: Allow users to input custom regex in certain fields inside of integration config, more details in relevant docs</li> </ul>"},{"location":"changelog.html#v0231","title":"v0.2.31","text":"<ul> <li>feat: Add limit range for <code>kube-RBAC-proxy</code></li> </ul>"},{"location":"customresources.html","title":"Custom Resources","text":"<p>Below is the detailed explanation about Custom Resources of MTO</p>"},{"location":"customresources.html#1-quota","title":"1. Quota","text":"<p>Cluster scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nname: medium\nannotations:\nquota.tenantoperator.stakater.com/is-default: \"false\"\nspec:\nresourcequota:\nhard:\nrequests.cpu: '5'\nlimits.cpu: '10'\nrequests.memory: '5Gi'\nlimits.memory: '10Gi'\nconfigmaps: \"10\"\npersistentvolumeclaims: \"4\"\nreplicationcontrollers: \"20\"\nsecrets: \"10\"\nservices: \"10\"\nservices.loadbalancers: \"2\"\nlimitrange:\nlimits:\n- type: \"Pod\"\nmax:\ncpu: \"2\"\nmemory: \"1Gi\"\nmin:\ncpu: \"200m\"\nmemory: \"100Mi\"\n- type: \"Container\"\nmax:\ncpu: \"2\"\nmemory: \"1Gi\"\nmin:\ncpu: \"100m\"\nmemory: \"50Mi\"\ndefault:\ncpu: \"300m\"\nmemory: \"200Mi\"\ndefaultRequest:\ncpu: \"200m\"\nmemory: \"100Mi\"\nmaxLimitRequestRatio:\ncpu: \"10\"\n</code></pre> <p>When several tenants share a single cluster with a fixed number of resources, there is a concern that one tenant could use more than its fair share of resources. Quota is a wrapper around OpenShift <code>ClusterResourceQuota</code> and <code>LimitRange</code> which provides administrators to limit resource consumption per <code>Tenant</code>. For more details Quota.Spec , LimitRange.Spec</p>"},{"location":"customresources.html#2-tenant","title":"2. Tenant","text":"<p>Cluster scoped resource:</p> <p>The smallest valid Tenant definition is given below (with just one field in its spec):</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: alpha\nspec:\nquota: small\n</code></pre> <p>Here is a more detailed Tenant definition, explained below:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: alpha\nspec:\nowners: # optional\nusers: # optional\n- dave@stakater.com\ngroups: # optional\n- alpha\neditors: # optional\nusers: # optional\n- jack@stakater.com\nviewers: # optional\nusers: # optional\n- james@stakater.com\nquota: medium # required\nsandboxConfig: # optional\nenabled: true # optional\nprivate: true # optional\nonDelete: # optional\ncleanNamespaces: false # optional\ncleanAppProject: true # optional\nargocd: # optional\nsourceRepos: # required\n- https://github.com/stakater/gitops-config\nappProject: # optional\nclusterResourceWhitelist: # optional\n- group: tronador.stakater.com\nkind: Environment\nnamespaceResourceBlacklist: # optional\n- group: \"\"\nkind: ConfigMap\nhibernation: # optional\nsleepSchedule: 23 * * * * # required\nwakeSchedule: 26 * * * * # required\nnamespaces: # optional\nwithTenantPrefix: # optional\n- dev\n- build\nwithoutTenantPrefix: # optional\n- preview\ncommonMetadata: # optional\nlabels: # optional\nstakater.com/team: alpha\nannotations: # optional\nopenshift.io/node-selector: node-role.kubernetes.io/infra=\nspecificMetadata: # optional\n- annotations: # optional\nstakater.com/user: dave\nlabels: # optional\nstakater.com/sandbox: true\nnamespaces: # optional\n- alpha-dave-stakater-sandbox\ntemplateInstances: # optional\n- spec: # optional\ntemplate: networkpolicy # required\nsync: true  # optional\nparameters: # optional\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\nselector: # optional\nmatchLabels: # optional\npolicy: network-restriction\n</code></pre> <ul> <li> <p>Tenant has 3 kinds of <code>Members</code>. Each member type should have different roles assigned to them. These roles are gotten from the IntegrationConfig's TenantRoles field. You can customize these roles to your liking, but by default the following configuration applies:</p> <ul> <li><code>Owners:</code> Users who will be owners of a tenant. They will have OpenShift admin-role assigned to their users, with additional access to create namespaces as well.</li> <li><code>Editors:</code> Users who will be editors of a tenant. They will have OpenShift edit-role assigned to their users.</li> <li><code>Viewers:</code> Users who will be viewers of a tenant. They will have OpenShift view-role assigned to their users.</li> <li>For more details, check out their definitions.</li> </ul> </li> <li> <p><code>Users</code> can be linked to the tenant by specifying there username in <code>owners.users</code>, <code>editors.users</code> and <code>viewers.users</code> respectively.</p> </li> <li> <p><code>Groups</code> can be linked to the tenant by specifying the group name in <code>owners.groups</code>, <code>editors.groups</code> and <code>viewers.groups</code> respectively.</p> </li> <li> <p>Tenant will have a <code>Quota</code> to limit resource consumption.</p> </li> <li> <p><code>sandboxConfig</code> is used to configure the tenant user sandbox feature</p> <ul> <li>Setting <code>enabled</code> to true will create sandbox namespaces for owners and editors.</li> <li>Sandbox will follow the following naming convention {TenantName}-{UserName}-sandbox.</li> <li>In case of groups, the sandbox namespaces will be created for each member of the group.</li> <li>Setting <code>private</code> to true will make those sandboxes be only visible to the user they belong to. By default, sandbox namespaces are visible to all tenant members</li> </ul> </li> <li> <p><code>onDelete</code> is used to tell Multi Tenant Operator what to do when a Tenant is deleted.</p> <ul> <li><code>cleanNamespaces</code> if the value is set to true MTO deletes all tenant namespaces when a <code>Tenant</code> is deleted. Default value is false.</li> <li><code>cleanAppProject</code> will keep the generated ArgoCD AppProject if the value is set to false. By default, the value is true.</li> </ul> </li> <li> <p><code>argocd</code> is required if you want to create an ArgoCD AppProject for the tenant.</p> <ul> <li><code>sourceRepos</code> contain a list of repositories that point to your GitOps.</li> <li><code>appProject</code> is used to set the <code>clusterResourceWhitelist</code> and <code>namespaceResourceBlacklist</code> resources. If these are also applied via <code>IntegrationConfig</code> then those applied via Tenant CR will have higher precedence for given Tenant.</li> </ul> </li> <li> <p><code>hibernation</code> can be used to create a schedule during which the namespaces belonging to the tenant will be put to sleep. The values of the <code>sleepSchedule</code> and <code>wakeSchedule</code> fields must be a string in a cron format.</p> </li> <li> <p>Namespaces can also be created via tenant CR by specifying names in <code>namespaces</code>.</p> <ul> <li>Multi Tenant Operator will append tenant name prefix while creating namespaces if the list of namespaces is under the <code>withTenantPrefix</code> field, so the format will be {TenantName}-{Name}.</li> <li>Namespaces listed under the <code>withoutTenantPrefix</code> will be created with the given name. Writing down namespaces here that already exist within the cluster are not allowed.</li> <li><code>stakater.com/kind: {Name}</code> label will also be added to the namespaces.</li> </ul> </li> <li> <p><code>commonMetadata</code> can be used to distribute common labels and annotations among tenant namespaces.</p> <ul> <li><code>labels</code> distributes provided labels among all tenant namespaces</li> <li><code>annotations</code> distributes provided annotations among all tenant namespaces</li> </ul> </li> <li> <p><code>specificMetadata</code> can be used to distribute specific labels and annotations among specific tenant namespaces.</p> <ul> <li><code>labels</code> distributes given labels among specific tenant namespaces</li> <li><code>annotations</code> distributes given annotations among specific tenant namespaces</li> <li><code>namespaces</code> consists a list of specific tenant namespaces across which the labels and annotations will be distributed</li> </ul> </li> <li> <p>Tenant automatically deploys <code>template</code> resource mentioned in <code>templateInstances</code> to matching tenant namespaces.</p> <ul> <li><code>Template</code> resources are created in those <code>namespaces</code> which belong to a <code>tenant</code> and contain <code>matching labels</code>.</li> <li><code>Template</code> resources are created in all <code>namespaces</code> of a <code>tenant</code> if <code>selector</code> field is empty.</li> </ul> </li> </ul> <p>\u26a0\ufe0f If same label or annotation key is being applied using different methods provided, then the highest precedence will be given to <code>specificMetadata</code> followed by <code>commonMetadata</code> and in the end would be the ones applied from <code>openshift.project.labels</code>/<code>openshift.project.annotations</code> in <code>IntegrationConfig</code></p>"},{"location":"customresources.html#3-template","title":"3. Template","text":"<p>Cluster scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: redis\nresources:\nhelm:\nreleaseName: redis\nchart:\nrepository:\nname: redis\nrepoUrl: https://charts.bitnami.com/bitnami\nvalues: |\nredisPort: 6379\n---\napiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: networkpolicy\nparameters:\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\nresources:\nmanifests:\n- kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\nname: deny-cross-ns-traffic\nspec:\npodSelector:\nmatchLabels:\nrole: db\npolicyTypes:\n- Ingress\n- Egress\ningress:\n- from:\n- ipBlock:\ncidr: \"${{CIDR_IP}}\"\nexcept:\n- 172.17.1.0/24\n- namespaceSelector:\nmatchLabels:\nproject: myproject\n- podSelector:\nmatchLabels:\nrole: frontend\nports:\n- protocol: TCP\nport: 6379\negress:\n- to:\n- ipBlock:\ncidr: 10.0.0.0/24\nports:\n- protocol: TCP\nport: 5978\n---\napiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: resource-mapping\nresources:\nresourceMappings:\nsecrets:\n- name: secret-s1\nnamespace: namespace-n1\nconfigMaps:\n- name: configmap-c1\nnamespace: namespace-n2\n</code></pre> <p>Templates are used to initialize Namespaces, share common resources across namespaces, and map secrets/configmaps from one namespace to other namespaces.</p> <ul> <li>They either contain one or more Kubernetes manifests, a reference to secrets/configmaps, or a Helm chart.</li> <li>They are being tracked by TemplateInstances in each Namespace they are applied to.</li> <li>They can contain pre-defined parameters such as ${namespace}/${tenant} or user-defined ${MY_PARAMETER} that can be specified within an TemplateInstance.</li> </ul> <p>Also you can define custom variables in <code>Template</code> and <code>TemplateInstance</code> . The parameters defined in <code>TemplateInstance</code> are overwritten the values defined in <code>Template</code> .</p> <p>Manifest Templates: The easiest option to define a Template is by specifying an array of Kubernetes manifests which should be applied when the Template is being instantiated.</p> <p>Helm Chart Templates: Instead of manifests, a Template can specify a Helm chart that will be installed (using Helm template) when the Template is being instantiated.</p> <p>Resource Mapping Templates: A template can be used to map secrets and configmaps from one tenant's namespace to another tenant's namespace, or within a tenant's namespace.</p>"},{"location":"customresources.html#mandatory-and-optional-templates","title":"Mandatory and Optional Templates","text":"<p>Templates can either be mandatory or optional. By default, all Templates are optional. Cluster Admins can make Templates mandatory by adding them to the <code>spec.templateInstances</code> array within the Tenant configuration. All Templates listed in <code>spec.templateInstances</code> will always be instantiated within every <code>Namespace</code> that is created for the respective Tenant.</p>"},{"location":"customresources.html#4-templateinstance","title":"4. TemplateInstance","text":"<p>Namespace scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: networkpolicy\nnamespace: build\nspec:\ntemplate: networkpolicy\nsync: true\nparameters:\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\n</code></pre> <p>TemplateInstance are used to keep track of resources created from Templates, which are being instantiated inside a Namespace. Generally, a TemplateInstance is created from a Template and then the TemplateInstances will not be updated when the Template changes later on. To change this behavior, it is possible to set <code>spec.sync: true</code> in a TemplateInstance. Setting this option, means to keep this TemplateInstance in sync with the underlying template (similar to Helm upgrade).</p>"},{"location":"customresources.html#5-templategroupinstance","title":"5. TemplateGroupInstance","text":"<p>Cluster scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: namespace-parameterized-restrictions-tgi\nspec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\n- beta\nparameters:\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\n</code></pre> <p>TemplateGroupInstance distributes a template across multiple namespaces which are selected by labelSelector.</p>"},{"location":"customresources.html#6-resourcesupervisor","title":"6. ResourceSupervisor","text":"<p>Cluster scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: tenant-sample\nspec:\nargocd:\nappProjects:\n- tenant-sample\nhibernation:\nsleepSchedule: 23 * * * *\nwakeSchedule: 26 * * * *\nnamespaces:\n- stage\n- dev\nstatus:\ncurrentStatus: running\nnextReconcileTime: '2022-07-07T11:23:00Z'\n</code></pre> <p>The <code>ResourceSupervisor</code> is a resource created by MTO in case the Hibernation feature is enabled. The Resource manages the sleep/wake schedule of the namespaces owned by the tenant, and manages the previous state of any sleeping application. Currently, only StatefulSets and Deployments are put to sleep. Additionally, ArgoCD AppProjects that belong to the tenant have a <code>deny</code> SyncWindow added to them.</p> <p>The <code>ResourceSupervisor</code> can be created both via the <code>Tenant</code> or manually. For more details, check some of its use cases</p>"},{"location":"customresources.html#namespace","title":"Namespace","text":"<pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nlabels:\nstakater.com/tenant: blue-sky\nname: build\n</code></pre> <ul> <li>Namespace should have label <code>stakater.com/tenant</code> which contains the name of tenant to which it belongs to. The labels and annotations specified in the operator config,  <code>ocp.labels.project</code> and <code>ocp.annotations.project</code> are inserted in the namespace by the controller.</li> </ul>"},{"location":"customresources.html#notes","title":"Notes","text":"<ul> <li><code>tenant.spec.users.owner</code>: Can only create Namespaces with required tenant label and can delete Projects. To edit Namespace use <code>GitOps/ArgoCD</code></li> </ul>"},{"location":"eula.html","title":"Multi Tenant Operator End User License Agreement","text":"<p>Last revision date: 12 December 2022</p> <p>IMPORTANT: THIS SOFTWARE END-USER LICENSE AGREEMENT (\"EULA\") IS A LEGAL AGREEMENT (\"Agreement\") BETWEEN YOU (THE CUSTOMER, EITHER AS AN INDIVIDUAL OR, IF PURCHASED OR OTHERWISE ACQUIRED BY OR FOR AN ENTITY, AS AN ENTITY) AND Stakater AB OR ITS SUBSIDUARY (\"COMPANY\"). READ IT CAREFULLY BEFORE COMPLETING THE INSTALLATION PROCESS AND USING MULTI TENANT OPERATOR (\"SOFTWARE\"). IT PROVIDES A LICENSE TO USE THE SOFTWARE AND CONTAINS WARRANTY INFORMATION AND LIABILITY DISCLAIMERS. BY INSTALLING AND USING THE SOFTWARE, YOU ARE CONFIRMING YOUR ACCEPTANCE OF THE SOFTWARE AND AGREEING TO BECOME BOUND BY THE TERMS OF THIS AGREEMENT.</p> <p>In order to use the Software under this Agreement, you must receive a license key at the time of purchase, in accordance with the scope of use and other terms specified and as set forth in Section 1 of this Agreement.</p>"},{"location":"eula.html#1-license-grant","title":"1. License Grant","text":"<ul> <li> <p>1.1 General Use. This Agreement grants you a non-exclusive, non-transferable, limited license to the use rights for the Software, subject to the terms and conditions in this Agreement. The Software is licensed, not sold.</p> </li> <li> <p>1.2 Electronic Delivery. All Software and license documentation shall be delivered by electronic means unless otherwise specified on the applicable invoice or at the time of purchase. Software shall be deemed delivered when it is made available for download for you by the Company (\"Delivery\").</p> </li> </ul>"},{"location":"eula.html#2-modifications","title":"2. Modifications","text":"<ul> <li> <p>2.1 No Modifications may be created of the original Software. \"Modification\" means:</p> <ul> <li> <p>(a) Any addition to or deletion from the contents of a file included in the original Software</p> </li> <li> <p>(b) Any new file that contains any part of the original Software</p> </li> </ul> </li> </ul>"},{"location":"eula.html#3-restricted-uses","title":"3. Restricted Uses","text":"<ul> <li> <p>3.1 You shall not (and shall not allow any third party to):</p> <ul> <li> <p>(a) reverse engineer the Software or attempt to reconstruct or discover any source code, underlying ideas, algorithms, file formats or programming interfaces of the Software by any means whatsoever (except and only to the extent that applicable law prohibits or restricts reverse engineering restrictions);</p> </li> <li> <p>(b) distribute, sell, sub-license, rent, lease or use the Software for time sharing, hosting, service provider or like purposes, except as expressly permitted under this Agreement;</p> </li> <li> <p>(c) redistribute the Software;</p> </li> <li> <p>(d) remove any product identification, proprietary, copyright or other notices contained in the Software;</p> </li> <li> <p>(e) modify any part of the Software, create a derivative work of any part of the Software (except as permitted in Section 4), or incorporate the Software, except to the extent expressly authorized in writing by the Company;</p> </li> <li> <p>(f) publicly disseminate performance information or analysis (including, without limitation, benchmarks) from any source relating to the Software;</p> </li> <li> <p>(g) utilize any equipment, device, software, or other means designed to circumvent or remove any form of Source URL or copy protection used by the Company in connection with the Software, or use the Software together with any authorization code, Source URL, serial number, or other copy protection device not supplied by the Company;</p> </li> <li> <p>(h) use the Software to develop a product which is competitive with any of the Company's product offerings;</p> </li> <li> <p>(i) use unauthorized Source URLs or license key(s) or distribute or publish Source URLs or license key(s), except as may be expressly permitted by the Company in writing. If your unique license is ever published, the Company reserves the right to terminate your access without notice.</p> </li> </ul> </li> <li> <p>3.2 Under no circumstances may you use the Software as part of a product or service that provides similar functionality to the Software itself.</p> </li> </ul>"},{"location":"eula.html#4-ownership","title":"4. Ownership","text":"<ul> <li>4.1 Notwithstanding anything to the contrary contained herein, except for the limited license rights expressly provided herein, the Company and its suppliers have and will retain all rights, title and interest (including, without limitation, all patent, copyright, trademark, trade secret and other intellectual property rights) in and to the Software and all copies, modifications and derivative works thereof (including any changes which incorporate any of your ideas, feedback or suggestions). You acknowledge that you are obtaining only a limited license right to the Software, and that irrespective of any use of the words \"purchase\", \"sale\" or like terms hereunder no ownership rights are being conveyed to you under this Agreement or otherwise.</li> </ul>"},{"location":"eula.html#5-fees-and-payment","title":"5. Fees and Payment","text":"<ul> <li>5.1 The Software license fees will be due and payable in full as set forth in the applicable invoice or at the time of purchase. You shall be responsible for all taxes, with-holdings, duties and levies arising from the order (excluding taxes based on the net income of the Company).</li> </ul>"},{"location":"eula.html#6-support-maintenance-and-services","title":"6. Support, Maintenance and Services","text":"<ul> <li>6.1 Subject to the terms and conditions of this Agreement, as set forth in your invoice, and as set forth on the Stakater support page, support and maintenance services may be included with the purchase of your license subscription.</li> </ul>"},{"location":"eula.html#7-disclaimer-of-warranties","title":"7. Disclaimer of Warranties","text":"<ul> <li> <p>7.1 The Software is provided \"as is\", with all faults, defects and errors, and without warranty of any kind. The Company does not warrant that the Software will be free of bugs, errors, or other defects, and the Company shall have no liability of any kind for the use of or inability to use the Software, the Software content or any associated service, and you acknowledge that it is not technically practicable for the Company to do so.</p> </li> <li> <p>7.2 To the maximum extent permitted by applicable law, the Company disclaims all warranties, express, implied, arising by law or otherwise, regarding the Software, the Software content and their respective performance or suitability for your intended use, including without limitation any implied warranty of merchantability, fitness for a particular purpose.</p> </li> </ul>"},{"location":"eula.html#8-limitation-of-liability","title":"8. Limitation of Liability","text":"<ul> <li> <p>8.1 In no event will the Company be liable for any direct, indirect, consequential, incidental, special, exemplary, or punitive damages or liabilities whatsoever arising from or relating to the Software, the Software content or this Agreement, whether based on contract, tort (including negligence), strict liability or other theory, even if the Company has been advised of the possibility of such damages.</p> </li> <li> <p>8.2 In no event will the Company's liability exceed the Software license price as indicated in the invoice. The existence of more than one claim will not enlarge or extend this limit.</p> </li> </ul>"},{"location":"eula.html#9-remedies","title":"9. Remedies","text":"<ul> <li> <p>9.1 Your exclusive remedy and the Company's entire liability for breach of this Agreement shall be limited, at the Company's sole and exclusive discretion, to:</p> <ul> <li> <p>(a) replacement of any defective software or documentation; or</p> </li> <li> <p>(b) refund of the license fee paid to the Company</p> </li> </ul> </li> </ul>"},{"location":"eula.html#10-acknowledgements","title":"10. Acknowledgements","text":"<ul> <li> <p>10.1 Consent to the Use of Data. You agree that the Company and its affiliates may collect and use technical information gathered as part of the product support services. The Company may use this information solely to improve products and services and will not disclose this information in a form that personally identifies individuals or organizations.</p> </li> <li> <p>10.2 Government End Users. If the Software and related documentation are supplied to or purchased by or on behalf of a Government, then the Software is deemed to be \"commercial software\" as that term is used in the acquisition regulation system.</p> </li> </ul>"},{"location":"eula.html#11-third-party-software","title":"11. Third Party Software","text":"<ul> <li> <p>11.1 Examples included in Software may provide links to third party libraries or code (collectively \"Third Party Software\") to implement various functions. Third Party Software does not comprise part of the Software. In some cases, access to Third Party Software may be included along with the Software delivery as a convenience for demonstration purposes. Licensee acknowledges:</p> <ul> <li> <p>(1) That some part of Third Party Software may require additional licensing of copyright and patents from the owners of such, and</p> </li> <li> <p>(2) That distribution of any of the Software referencing or including any portion of a Third Party Software may require appropriate licensing from such third parties</p> </li> </ul> </li> </ul>"},{"location":"eula.html#12-miscellaneous","title":"12. Miscellaneous","text":"<ul> <li> <p>12.1 Entire Agreement. This Agreement sets forth our entire agreement with respect to the Software and the subject matter hereof and supersedes all prior and contemporaneous understandings and agreements whether written or oral.</p> </li> <li> <p>12.2 Amendment. The Company reserves the right, in its sole discretion, to amend this Agreement from time. Amendments are managed as described in General Provisions.</p> </li> <li> <p>12.3 Assignment. You may not assign this Agreement or any of its rights under this Agreement without the prior written consent of The Company and any attempted assignment without such consent shall be void.</p> </li> <li> <p>12.4 Export Compliance. You agree to comply with all applicable laws and regulations, including laws, regulations, orders or other restrictions on export, re-export or redistribution of software.</p> </li> <li> <p>12.5 Indemnification. You agree to defend, indemnify, and hold harmless the Company from and against any lawsuits, claims, losses, damages, fines and expenses (including attorneys' fees and costs) arising out of your use of the Software or breach of this Agreement.</p> </li> <li> <p>12.6 Attorneys' Fees and Costs. The prevailing party in any action to enforce this Agreement will be entitled to recover its attorneys' fees and costs in connection with such action.</p> </li> <li> <p>12.7 Severability. If any provision of this Agreement is held by a court of competent jurisdiction to be invalid, illegal, or unenforceable, the remainder of this Agreement will remain in full force and effect.</p> </li> <li> <p>12.8 Waiver. Failure or neglect by either party to enforce at any time any of the provisions of this license Agreement shall not be construed or deemed to be a waiver of that party's rights under this Agreement.</p> </li> <li> <p>12.9 Audit. The Company may, at its expense, appoint its own personnel or an independent third party to audit the numbers of installations of the Software in use by you. Any such audit shall be conducted upon thirty (30) days prior notice, during regular business hours and shall not unreasonably interfere with your business activities.</p> </li> <li> <p>12.10 Headings. The headings of sections and paragraphs of this Agreement are for convenience of reference only and are not intended to restrict, affect or be of any weight in the interpretation or construction of the provisions of such sections or paragraphs.</p> </li> </ul>"},{"location":"eula.html#13-contact-information","title":"13. Contact Information","text":"<ul> <li>13.1 If you have any questions about this EULA, or if you want to contact the Company for any reason, please direct correspondence to <code>sales@stakater.com</code>.</li> </ul>"},{"location":"faq.html","title":"FAQs","text":""},{"location":"faq.html#q-error-received-while-performing-create-update-or-delete-action-on-namespace-cannot-create-namespace-test-john-without-label-stakatercomtenant","title":"Q. Error received while performing Create, Update or Delete action on namespace <code>\"Cannot CREATE namespace test-john without label stakater.com/tenant\"</code>","text":"<p>A. Error occurs when a user is trying to perform create, update, delete action on a namespace without the required <code>stakater.com/tenant</code> label. This label is used by the operator to see that authorized users can perform that action on the namespace. Just add the label with the tenant name so that MTO knows which tenant the namespace belongs to, and who is authorized to perform create/update/delete operations. For more details please refer to Namespace use-case.</p>"},{"location":"faq.html#q-how-do-i-deploy-cluster-scoped-resource-via-the-argocd-integration","title":"Q. How do I deploy cluster-scoped resource via the ArgoCD integration?","text":"<p>A. Multi-Tenant Operator's ArgoCD Integration allows configuration of which cluster-scoped resources can be deployed, both globally and on a per-tenant basis. For a global whitelist that applies to all tenants, you can add both resource <code>group</code> and  <code>kind</code> to the IntegrationConfig's <code>spec.argocd.clusterResourceWhitelist</code> field. Alternatively, you can set this up on a tenant level by configuring the same details within a Tenant's <code>spec.argocd.appProject.clusterResourceWhitelist</code> field. For more details, check out the ArgoCD integration use cases</p>"},{"location":"faq.html#q-invalidspecerror-application-repo-repo-is-not-permitted-in-project-project","title":"Q. InvalidSpecError: application repo \\&lt;repo&gt; is not permitted in project \\&lt;project&gt;","text":"<p>A. The above error can occur if the ArgoCD Application is syncing from a source that is not allowed the referenced AppProject. To solve this, verify that you have referred to the correct project in the given ArgoCD Application, and that the repoURL used for the Application's source is valid. If the error still appears, you can add the URL to the relevant Tenant's <code>spec.argocd.sourceRepos</code> array.</p>"},{"location":"features.html","title":"Features","text":"<p>The major features of Multi Tenant Operator (MTO) are described below.</p>"},{"location":"features.html#kubernetes-multitenancy","title":"Kubernetes Multitenancy","text":"<p>RBAC is one of the most complicated and error-prone parts of Kubernetes. With Multi Tenant Operator, you can rest assured that RBAC is configured with the \"least privilege\" mindset and all rules are kept up-to-date with zero manual effort.</p> <p>Multi Tenant Operator binds existing ClusterRoles to the Tenant's Namespaces used for managing access to the Namespaces and the resources they contain. You can also modify the default roles or create new roles to have full control and customize access control for your users and teams.</p> <p>Multi Tenant Operator is also able to leverage existing OpenShift groups or external groups synced from 3rd party identity management systems, for maintaining Tenant membership in your organization's current user management system.</p>"},{"location":"features.html#hashicorp-vault-multitenancy","title":"HashiCorp Vault Multitenancy","text":"<p>Multi Tenant Operator extends the tenants permission model to HashiCorp Vault where it can create Vault paths and greatly ease the overhead of managing RBAC in Vault. Tenant users can manage their own secrets without the concern of someone else having access to their Vault paths.</p> <p>More details on Vault Multitenancy</p>"},{"location":"features.html#argocd-multitenancy","title":"ArgoCD Multitenancy","text":"<p>Multi Tenant Operator is not only providing strong Multi Tenancy for the OpenShift internals but also extends the tenants permission model to ArgoCD were it can provision AppProjects and Allowed Repositories for your tenants greatly ease the overhead of managing RBAC in ArgoCD.</p> <p>More details on ArgoCD Multitenancy</p>"},{"location":"features.html#mattermost-multitenancy","title":"Mattermost Multitenancy","text":"<p>Multi Tenant Operator can manage Mattermost to create Teams for tenant users. All tenant users get a unique team and a list of predefined channels gets created. When a user is removed from the tenant, the user is also removed from the Mattermost team corresponding to tenant.</p> <p>More details on Mattermost</p>"},{"location":"features.html#costresource-optimization","title":"Cost/Resource Optimization","text":"<p>Multi Tenant Operator provides a mechanism for defining Resource Quotas at the tenant scope, meaning all namespaces belonging to a particular tenant share the defined quota, which is why you are able to safely enable dev teams to self serve their namespaces whilst being confident that they can only use the resources allocated based on budget and business needs.</p> <p>More details on Quota</p>"},{"location":"features.html#remote-development-namespaces","title":"Remote Development Namespaces","text":"<p>Multi Tenant Operator can be configured to automatically provision a namespace in the cluster for every member of the specific tenant, that will also be preloaded with any selected templates and consume the same pool of resources from the tenants quota creating safe remote dev namespaces that teams can use as scratch namespace for rapid prototyping and development. So, every developer gets a Kubernetes-based cloud development environment that feel like working on localhost.</p> <p>More details on Sandboxes</p>"},{"location":"features.html#templates-and-template-distribution","title":"Templates and Template distribution","text":"<p>Multi Tenant Operator allows admins/users to define templates for namespaces, so that others can instantiate these templates to provision namespaces with batteries loaded. A template could pre-populate a namespace for certain use cases or with basic tooling required. Templates allow you to define Kubernetes manifests, Helm chart and more to be applied when the template is used to create a namespace.</p> <p>It also allows the parameterizing of these templates for flexibility and ease of use. It also provides the option to enforce the presence of templates in one tenant's or all the tenants' namespaces for configuring secure defaults.</p> <p>Common use cases for namespace templates may be:</p> <ul> <li>Adding networking policies for multitenancy</li> <li>Adding development tooling to a namespace</li> <li>Deploying pre-populated databases with test data</li> <li>Injecting new namespaces with optional credentials such as image pull secrets</li> </ul> <p>More details on Distributing Template Resources</p>"},{"location":"features.html#hibernation","title":"Hibernation","text":"<p>Multi Tenant Operator can downscale Deployments and StatefulSets in a tenant's Namespace according to a defined  sleep schedule. The Deployments and StatefulSets are brought back to their required replicas according to the provided wake schedule.</p> <p>More details on Hibernation</p>"},{"location":"features.html#cross-namespace-resource-distribution","title":"Cross Namespace Resource Distribution","text":"<p>Multi Tenant Operator supports cloning of secrets and configmaps from one namespace to another namespace based on label selectors. It uses templates to enable users to provide reference to secrets and configmaps. It uses a template group instance to distribute those secrets and namespaces in matching namespaces, even if namespaces belong to different tenants. If template instance is used then the resources will only be mapped if namespaces belong to same tenant.</p> <p>More details on Distributing Secrets and ConfigMaps</p>"},{"location":"features.html#self-service","title":"Self-Service","text":"<p>With Multi Tenant Operator, you can empower your users to safely provision namespaces for themselves and their teams (typically mapped to SSO groups). Team-owned namespaces and the resources inside them count towards the team's quotas rather than the user's individual limits and are automatically shared with all team members according to the access rules you configure in Multi Tenant Operator.</p> <p>Also, by leveraging Multi Tenant Operator's templating mechanism, namespaces can be provisioned and automatically pre-populated with any kind of resource or multiple resources such as network policies, docker pull secrets or even Helm charts etc</p>"},{"location":"features.html#everything-as-codegitops-ready","title":"Everything as Code/GitOps Ready","text":"<p>Multi Tenant Operator is designed and built to be 100% OpenShift-native and to be configured and managed the same familiar way as native OpenShift resources so is perfect for modern shops that are dedicated to GitOps as it is fully configurable using Custom Resources.</p>"},{"location":"features.html#preventing-clusters-sprawl","title":"Preventing Clusters Sprawl","text":"<p>As companies look to further harness the power of cloud-native, they are adopting container technologies at rapid speed, increasing the number of clusters and workloads. As the number of Kubernetes clusters grows, this is an increasing work for the Ops team. When it comes to patching security issues or upgrading clusters, teams are doing five times the amount of work.</p> <p>With Multi Tenant Operator teams can share a single cluster with multiple teams, groups of users, or departments by saving operational and management efforts. This prevents you from Kubernetes cluster sprawl.</p>"},{"location":"features.html#native-experience","title":"Native Experience","text":"<p>Multi Tenant Operator provides multi-tenancy with a native Kubernetes experience without introducing additional management layers, plugins, or customized binaries.</p>"},{"location":"hibernation.html","title":"Hibernating Namespaces","text":"<p>You can manage workloads in your cluster with MTO by implementing a hibernation schedule for your tenants. Hibernation downsizes the running Deployments and StatefulSets in a tenant\u2019s namespace according to a defined cron schedule. You can set a hibernation schedule for your tenants by adding the \u2018spec.hibernation\u2019 field to the tenant's respective Custom Resource.</p> <pre><code>hibernation:\nsleepSchedule: 23 * * * *\nwakeSchedule: 26 * * * *\n</code></pre> <p><code>spec.hibernation.sleepSchedule</code> accepts a cron expression indicating the time to put the workloads in your tenant\u2019s namespaces to sleep.</p> <p><code>spec.hibernation.wakeSchedule</code> accepts a cron expression indicating the time to wake the workloads in your tenant\u2019s namespaces up.</p> <p>Note</p> <p>Both sleep and wake schedules must be specified for your Hibernation schedule to be valid.</p> <p>Additionally, adding the <code>hibernation.stakater.com/exclude: 'true'</code> annotation to a namespace excludes it from hibernating.</p> <p>Note</p> <p>This is only true for hibernation applied via the Tenant Custom Resource, and does not apply for hibernation done by manually creating a ResourceSupervisor (details about that below).</p> <p>Note</p> <p>This will not wake up an already sleeping namespace before the wake schedule.</p>"},{"location":"hibernation.html#resource-supervisor","title":"Resource Supervisor","text":"<p>Adding a Hibernation Schedule to a Tenant creates an accompanying ResourceSupervisor Custom Resource. The Resource Supervisor stores the Hibernation schedules and manages the current and previous states of all the applications, whether they are sleeping or awake.</p> <p>When the sleep timer is activated, the Resource Supervisor controller stores the details of your applications (including the number of replicas, configurations, etc.) in the applications' namespaces and then puts your applications to sleep. When the wake timer is activated, the controller wakes up the applications using their stored details.</p> <p>Enabling ArgoCD support for Tenants will also hibernate applications in the tenants' <code>appProjects</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: sigma\nspec:\nargocd:\nappProjects:\n- sigma\nnamespace: openshift-gitops\nhibernation:\nsleepSchedule: 42 * * * *\nwakeSchedule: 45 * * * *\nnamespaces:\n- tenant-ns1\n- tenant-ns2\n</code></pre> <p>Currently, Hibernation is available only for StatefulSets and Deployments.</p>"},{"location":"hibernation.html#manual-creation-of-resourcesupervisor","title":"Manual creation of ResourceSupervisor","text":"<p>Hibernation can also be applied by creating a ResourceSupervisor resource manually. The ResourceSupervisor definition will contain the hibernation cron schedule, the names of the namespaces to be hibernated, and the names of the ArgoCD AppProjects whose ArgoCD Applications have to be hibernated (as per the given schedule).</p> <p>This method can be used to hibernate:</p> <ul> <li>Some specific namespaces and AppProjects in a tenant</li> <li>A set of namespaces and AppProjects belonging to different tenants</li> <li>Namespaces and AppProjects belonging to a tenant that the cluster admin is not a member of</li> <li>Non-tenant namespaces and ArgoCD AppProjects</li> </ul> <p>As an example, the following ResourceSupervisor could be created manually, to apply hibernation explicitly to the 'ns1' and 'ns2' namespaces, and to the 'sample-app-project' AppProject.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: hibernator\nspec:\nargocd:\nappProjects:\n- sample-app-project\nnamespace: openshift-gitops\nhibernation:\nsleepSchedule: 42 * * * *\nwakeSchedule: 45 * * * *\nnamespaces:\n- ns1\n- ns2\n</code></pre>"},{"location":"installation.html","title":"Installation","text":"<p>This document contains instructions on installing, uninstalling and configuring Multi Tenant Operator using OpenShift MarketPlace.</p> <ol> <li> <p>OpenShift OperatorHub UI</p> </li> <li> <p>CLI/GitOps</p> </li> <li> <p>Uninstall</p> </li> </ol>"},{"location":"installation.html#requirements","title":"Requirements","text":"<ul> <li>An OpenShift cluster [v4.7 - v4.12]</li> </ul>"},{"location":"installation.html#installing-via-operatorhub-ui","title":"Installing via OperatorHub UI","text":"<ul> <li>After opening OpenShift console click on <code>Operators</code>, followed by <code>OperatorHub</code> from the side menu</li> </ul> <ul> <li>Now search for <code>Multi Tenant Operator</code> and then click on <code>Multi Tenant Operator</code> tile</li> </ul> <ul> <li>Click on the <code>install</code> button</li> </ul> <ul> <li>Select <code>Updated channel</code>. Select <code>multi-tenant-operator</code> to install the operator in <code>multi-tenant-operator</code> namespace from <code>Installed Namespace</code> dropdown menu. After configuring <code>Update approval</code> click on the <code>install</code> button.</li> </ul> <p>Note: Use <code>stable</code> channel for seamless upgrades. For <code>Production Environment</code> prefer <code>Manual</code> approval and use <code>Automatic</code> for <code>Development Environment</code></p> <p></p> <ul> <li>Wait for the operator to be installed</li> </ul> <p></p> <ul> <li>Once successfully installed, MTO will be ready to enforce multi-tenancy in your cluster</li> </ul> <p></p> <p>Note: MTO will be installed in <code>multi-tenant-operator</code> namespace.</p>"},{"location":"installation.html#configuring-integrationconfig","title":"Configuring IntegrationConfig","text":"<p>IntegrationConfig is required to configure the settings of multi-tenancy for MTO.</p> <ul> <li>We recommend using the following IntegrationConfig as a starting point</li> </ul> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: multi-tenant-operator\nspec:\nopenshift:\nprivilegedNamespaces:\n- default\n- ^openshift-*\n- ^kube-*\n- ^redhat-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:default-*\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\n- ^system:serviceaccount:redhat-*\n</code></pre> <p>For more details and configurations check out IntegrationConfig.</p>"},{"location":"installation.html#installing-via-cli-or-gitops","title":"Installing via CLI OR GitOps","text":"<ul> <li>Create namespace <code>multi-tenant-operator</code></li> </ul> <pre><code>oc create namespace multi-tenant-operator\nnamespace/multi-tenant-operator created\n</code></pre> <ul> <li>Create an OperatorGroup YAML for MTO and apply it in <code>multi-tenant-operator</code> namespace.</li> </ul> <pre><code>oc create -f - &lt;&lt; EOF\napiVersion: operators.coreos.com/v1\nkind: OperatorGroup\nmetadata:\n  name: tenant-operator\n  namespace: multi-tenant-operator\nEOF\noperatorgroup.operators.coreos.com/tenant-operator created\n</code></pre> <ul> <li>Create a subscription YAML for MTO and apply it in <code>multi-tenant-operator</code> namespace. To enable console set <code>.spec.config.env[].ENABLE_CONSOLE</code> to <code>true</code>. This will create a route resource, which can be used to access the Multi-Tenant-Operator console.</li> </ul> <pre><code>oc create -f - &lt;&lt; EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: Subscription\nmetadata:\n  name: tenant-operator\n  namespace: multi-tenant-operator\nspec:\n  channel: stable\n  installPlanApproval: Automatic\n  name: tenant-operator\n  source: certified-operators\n  sourceNamespace: openshift-marketplace\n  startingCSV: tenant-operator.v0.9.1\n  config:\n    env:\n      - name: ENABLE_CONSOLE\n        value: 'true'\nEOF\nsubscription.operators.coreos.com/tenant-operator created\n</code></pre> <p>Note: To bring MTO via GitOps, add the above files in GitOps repository.</p> <ul> <li>After creating the <code>subscription</code> custom resource open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu</li> </ul> <p></p> <ul> <li>Wait for the installation to complete</li> </ul> <p></p> <ul> <li>Once the installation is complete click on <code>Workloads</code>, followed by <code>Pods</code> from the side menu and select <code>multi-tenant-operator</code> project</li> </ul> <p></p> <ul> <li>Once pods are up and running, MTO will be ready to enforce multi-tenancy in your cluster</li> </ul> <p></p>"},{"location":"installation.html#configuring-integrationconfig_1","title":"Configuring IntegrationConfig","text":"<p>IntegrationConfig is required to configure the settings of multi-tenancy for MTO.</p> <ul> <li>We recommend using the following IntegrationConfig as a starting point:</li> </ul> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: multi-tenant-operator\nspec:\nopenshift:\nprivilegedNamespaces:\n- default\n- ^openshift-*\n- ^kube-*\n- ^redhat-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:default-*\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\n- ^system:serviceaccount:redhat-*\n</code></pre> <p>For more details and configurations check out IntegrationConfig.</p>"},{"location":"installation.html#uninstall-via-operatorhub-ui","title":"Uninstall via OperatorHub UI","text":"<p>You can uninstall MTO by following these steps:</p> <ul> <li> <p>Decide on whether you want to retain tenant namespaces and ArgoCD AppProjects or not. If yes, please set <code>spec.onDelete.cleanNamespaces</code> to <code>false</code> for all those tenants whose namespaces you want to retain, and <code>spec.onDelete.cleanAppProject</code> to <code>false</code> for all those tenants whose AppProject you want to retain. For more details check out onDelete</p> </li> <li> <p>After making the required changes open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu</p> </li> </ul> <p></p> <ul> <li>Now click on uninstall and confirm uninstall.</li> </ul> <p></p> <ul> <li> <p>Now the operator has been uninstalled.</p> </li> <li> <p><code>Optional:</code> you can also manually remove MTO's CRDs and its resources from the cluster.</p> </li> </ul>"},{"location":"installation.html#notes","title":"Notes","text":"<ul> <li>For more details on how to use MTO please refer use-cases.</li> <li>For more details on how to extend your MTO manager ClusterRole please refer extend-admin-clusterrole.</li> </ul>"},{"location":"integration-config.html","title":"Integration Config","text":"<p>IntegrationConfig is used to configure settings of multi-tenancy for Multi Tenant Operator.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\ntenantRoles:\ndefault:\nowner:\nclusterRoles:\n- admin\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\n- viewer\ncustom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/kind\noperator: In\nvalues:\n- build\nmatchLabels:\nstakater.com/kind: dev\nowner:\nclusterRoles:\n- custom-owner\neditor:\nclusterRoles:\n- custom-editor\nviewer:\nclusterRoles:\n- custom-viewer\n- custom-view\nopenshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\ngroup:\nlabels:\nrole: customer-reader\nsandbox:\nlabels:\nstakater.com/kind: sandbox\nclusterAdminGroups:\n- cluster-admins\nprivilegedNamespaces:\n- ^default$\n- ^openshift-*\n- ^kube-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\nnamespaceAccessPolicy:\ndeny:\nprivilegedNamespaces:\nusers:\n- system:serviceaccount:openshift-argocd:argocd-application-controller\n- adam@stakater.com\ngroups:\n- cluster-admins\nargocd:\nnamespace: openshift-operators\nnamespaceResourceBlacklist:\n- group: '' # all groups\nkind: ResourceQuota\nclusterResourceWhitelist:\n- group: tronador.stakater.com\nkind: EnvironmentProvisioner\nrhsso:\nenabled: true\nrealm: customer\nendpoint:\nurl: https://iam-keycloak-auth.apps.prod.abcdefghi.kubeapp.cloud/\nsecretReference:\nname: auth-secrets\nnamespace: openshift-auth\nvault:\nenabled: true\nendpoint:\nurl: https://vault.apps.prod.abcdefghi.kubeapp.cloud/\nsecretReference:\nname: vault-root-token\nnamespace: vault\nsso:\nclientName: vault\naccessorID: &lt;ACCESSOR_ID_TOKEN&gt;\n</code></pre> <p>Following are the different components that can be used to configure multi-tenancy in a cluster via Multi Tenant Operator.</p>"},{"location":"integration-config.html#tenantroles","title":"TenantRoles","text":"<p>TenantRoles are required within the IntegrationConfig, as they are used for defining what roles will be applied to each Tenant namespace. The field allows optional custom roles, that are then used to create RoleBindings for namespaces that match a labelSelector.</p> <p>\u26a0\ufe0f If you do not configure roles in any way, then the default OpenShift roles of <code>owner</code>, <code>edit</code>, and <code>view</code> will apply to Tenant members. Their details can be found here</p> <pre><code>tenantRoles:\ndefault:\nowner:\nclusterRoles:\n- admin\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\n- viewer\ncustom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/kind\noperator: In\nvalues:\n- build\nmatchLabels:\nstakater.com/kind: dev\nowner:\nclusterRoles:\n- custom-owner\neditor:\nclusterRoles:\n- custom-editor\nviewer:\nclusterRoles:\n- custom-viewer\n- custom-view\n</code></pre>"},{"location":"integration-config.html#default","title":"Default","text":"<p>This field contains roles that will be used to create default roleBindings for each namespace that belongs to tenants. These roleBindings are only created for a namespace if that namespaces isn't already matched by the <code>custom</code> field below it. Therefore, it is required to have at least one role mentioned within each of its three subfields: <code>owner</code>, <code>editor</code>, and <code>viewer</code>. These 3 subfields also correspond to the member fields of the Tenant CR</p>"},{"location":"integration-config.html#custom","title":"Custom","text":"<p>An array of custom roles. Similar to the <code>default</code> field, you can mention roles within this field as well. However, the custom roles also require the use of a <code>labelSelector</code> for each iteration within the array. The roles mentioned here will only apply to the namespaces that are matched by the labelSelector. If a namespace is matched by 2 different labelSelectors, then both roles will apply to it. Additionally, roles can be skipped within the labelSelector. These missing roles are then inherited from the <code>default</code> roles field . For example, if the following custom roles arrangement is used:</p> <pre><code>custom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/kind\noperator: In\nvalues:\n- build\nmatchLabels:\nstakater.com/kind: dev\nowner:\nclusterRoles:\n- custom-owner\n</code></pre> <p>Then the <code>editor</code> and <code>viewer</code> roles will be taken from the <code>default</code> roles field, as that is required to have at least one role mentioned.</p>"},{"location":"integration-config.html#openshift","title":"OpenShift","text":"<pre><code>openshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\ngroup:\nlabels:\nrole: customer-reader\nsandbox:\nlabels:\nstakater.com/kind: sandbox\nclusterAdminGroups:\n- cluster-admins\nprivilegedNamespaces:\n- ^default$\n- ^openshift-*\n- ^kube-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\nnamespaceAccessPolicy:\ndeny:\nprivilegedNamespaces:\nusers:\n- system:serviceaccount:openshift-argocd:argocd-application-controller\n- adam@stakater.com\ngroups:\n- cluster-admins\n</code></pre>"},{"location":"integration-config.html#project-group-and-sandbox","title":"Project, group and sandbox","text":"<p>We can use the <code>openshift.project</code>, <code>openshift.group</code> and <code>openshift.sandbox</code> fields to automatically add <code>labels</code> and <code>annotations</code> to  the Projects and Groups managed via MTO.</p> <pre><code>  openshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\ngroup:\nlabels:\nrole: customer-reader\nsandbox:\nlabels:\nstakater.com/kind: sandbox\n</code></pre> <p>If we want to add default labels/annotations to sandbox namespaces of tenants than we just simply add them in <code>openshift.project.labels</code>/<code>openshift.project.annotations</code> respectively.</p> <p>Whenever a project is made it will have the labels and annotations as mentioned above.</p> <pre><code>kind: Project\napiVersion: project.openshift.io/v1\nmetadata:\nname: bluesky-build\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\nlabels:\nworkload-monitoring: 'true'\nstakater.com/tenant: bluesky\nspec:\nfinalizers:\n- kubernetes\nstatus:\nphase: Active\n</code></pre> <pre><code>kind: Group\napiVersion: user.openshift.io/v1\nmetadata:\nname: bluesky-owner-group\nlabels:\nrole: customer-reader\nusers:\n- andrew@stakater.com\n</code></pre>"},{"location":"integration-config.html#cluster-admin-groups","title":"Cluster Admin Groups","text":"<p><code>clusterAdminGroups:</code> Contains names of the groups that are allowed to perform CRUD operations on namespaces present on the cluster. Users in the specified group(s) will be able to perform these operations without MTO getting in their way</p>"},{"location":"integration-config.html#privileged-namespaces","title":"Privileged Namespaces","text":"<p><code>privilegedNamespaces:</code> Contains the list of <code>namespaces</code> ignored by MTO. MTO will not manage the <code>namespaces</code> in this list. Values in this list are regex patterns. For example:</p> <ul> <li>To ignore the <code>default</code> namespace, we can specify <code>^default$</code></li> <li>To ignore all namespaces starting with the <code>openshift-</code> prefix, we can specify <code>^openshift-*</code>.</li> <li>To ignore any namespace containing <code>stakater</code> in its name, we can specify <code>stakater</code>. (A constant word given as a regex pattern will match any namespace containing that word.)</li> </ul>"},{"location":"integration-config.html#privileged-serviceaccounts","title":"Privileged ServiceAccounts","text":"<p><code>privilegedServiceAccounts:</code> Contains the list of <code>ServiceAccounts</code> ignored by MTO. MTO will not manage the <code>ServiceAccounts</code> in this list. Values in this list are regex patterns. For example, to ignore all <code>ServiceAccounts</code> starting with the <code>system:serviceaccount:openshift-</code> prefix, we can use <code>^system:serviceaccount:openshift-*</code>; and to ignore the <code>system:serviceaccount:builder</code> service account we can use <code>^system:serviceaccount:builder$.</code></p>"},{"location":"integration-config.html#namespace-access-policy","title":"Namespace Access Policy","text":"<p><code>namespaceAccessPolicy.Deny:</code> Can be used to restrict privileged users/groups CRUD operation over managed namespaces.</p> <pre><code>namespaceAccessPolicy:\ndeny:\nprivilegedNamespaces:\ngroups:\n- cluster-admins\nusers:\n- system:serviceaccount:openshift-argocd:argocd-application-controller\n- adam@stakater.com\n</code></pre> <p>\u26a0\ufe0f If you want to use a more complex regex pattern (for the <code>openshift.privilegedNamespaces</code> or <code>openshift.privilegedServiceAccounts</code> field), it is recommended that you test the regex pattern first -  either locally or using a platform such as https://regex101.com/.</p>"},{"location":"integration-config.html#argocd","title":"ArgoCD","text":""},{"location":"integration-config.html#namespace","title":"Namespace","text":"<p><code>argocd.namespace</code> is an optional field used to specify the namespace where ArgoCD Applications and AppProjects are deployed. The field should be populated when you want to create an ArgoCD AppProject for each tenant.</p>"},{"location":"integration-config.html#namespaceresourceblacklist","title":"NamespaceResourceBlacklist","text":"<pre><code>argocd:\nnamespaceResourceBlacklist:\n- group: '' # all resource groups\nkind: ResourceQuota\n- group: ''\nkind: LimitRange\n- group: ''\nkind: NetworkPolicy\n</code></pre> <p><code>argocd.namespaceResourceBlacklist</code> prevents ArgoCD from syncing the listed resources from your GitOps repo.</p>"},{"location":"integration-config.html#clusterresourcewhitelist","title":"ClusterResourceWhitelist","text":"<pre><code>argocd:\nclusterResourceWhitelist:\n- group: tronador.stakater.com\nkind: EnvironmentProvisioner\n</code></pre> <p><code>argocd.clusterResourceWhitelist</code> allows ArgoCD to sync the listed cluster scoped resources from your GitOps repo.</p>"},{"location":"integration-config.html#rhsso-red-hat-single-sign-on","title":"RHSSO (Red Hat Single Sign-On)","text":"<p>Red Hat Single Sign-On RHSSO is based on the Keycloak project and enables you to secure your web applications by providing Web single sign-on (SSO) capabilities based on popular standards such as SAML 2.0, OpenID Connect and OAuth 2.0.</p> <p>If <code>RHSSO</code> is configured on a cluster, then RHSSO configuration can be enabled.</p> <pre><code>rhsso:\nenabled: true\nrealm: customer\nendpoint:\nsecretReference:\nname: auth-secrets\nnamespace: openshift-auth\nurl: https://iam-keycloak-auth.apps.prod.abcdefghi.kubeapp.cloud/\n</code></pre> <p>If enabled, than admins have to provide secret and URL of RHSSO.</p> <ul> <li><code>secretReference.name:</code> Will contain the name of the secret.</li> <li><code>secretReference.namespace:</code> Will contain the namespace of the secret.</li> <li><code>realm:</code> Will contain the realm name which is configured for users.</li> <li><code>url:</code> Will contain the URL of RHSSO.</li> </ul>"},{"location":"integration-config.html#vault","title":"Vault","text":"<p>Vault is used to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.</p> <p>If <code>vault</code> is configured on a cluster, then Vault configuration can be enabled.</p> <pre><code>Vault:\nenabled: true\nendpoint:\nsecretReference:\nname: vault-root-token\nnamespace: vault\nurl: &gt;-\nhttps://vault.apps.prod.abcdefghi.kubeapp.cloud/\nsso:\naccessorID: &lt;ACCESSOR_ID_TOKEN&gt;\nclientName: vault\n</code></pre> <p>If enabled, than admins have to provide secret, URL and SSO accessorID of Vault.</p> <ul> <li><code>secretReference.name:</code> Will contain the name of the secret.</li> <li><code>secretReference.namespace:</code> Will contain the namespace of the secret.</li> <li><code>url:</code> Will contain the URL of Vault.</li> <li><code>sso.accessorID:</code> Will contain the SSO accessorID.</li> <li><code>sso.clientName:</code> Will contain the client name.</li> </ul> <p>For more details please refer use-cases</p>"},{"location":"introduction.html","title":"Introduction","text":"<p>OpenShift is designed to support a single tenant platform, hence making it difficult for cluster admins to host multi-tenancy in a single OpenShift cluster. If multi-tenancy is achieved by sharing a cluster, it can have many advantages, e.g. efficient resource utilization, less configuration effort and easier sharing of cluster-internal resources among different tenants. OpenShift and all managed applications provide enough primitive resources to achieve multi-tenancy, but it requires professional skills and deep knowledge of OpenShift.</p> <p>This is where Multi Tenant Operator (MTO) comes in and provides easy to manage/configure multi-tenancy. MTO provides wrappers around OpenShift resources to provide a higher level of abstraction to users. With MTO admins can configure Network and Security Policies, Resource Quotas, Limit Ranges, RBAC for every tenant, which are automatically inherited by all the namespaces and users in the tenant. Depending on the user's role, they are free to operate within their tenants in complete autonomy. MTO supports initializing new tenants using GitOps management pattern. Changes can be managed via PRs just like a typical GitOps workflow, so tenants can request changes, add new users, or remove users.</p> <p>The idea of MTO is to use namespaces as independent sandboxes, where tenant applications can run independently of each other. Cluster admins shall configure MTO's custom resources, which then become a self-service system for tenants. This minimizes the efforts of the cluster admins.</p> <p>MTO enables cluster admins to host multiple tenants in a single OpenShift Cluster, i.e.:</p> <ul> <li>Share an OpenShift cluster with multiple tenants</li> <li>Share managed applications with multiple tenants</li> <li>Configure and manage tenants and their sandboxes</li> </ul> <p>MTO is also OpenShift certified</p>"},{"location":"introduction.html#features","title":"Features","text":"<p>The major features of Multi Tenant Operator (MTO) are described below.</p>"},{"location":"introduction.html#kubernetes-multitenancy","title":"Kubernetes Multitenancy","text":"<p>RBAC is one of the most complicated and error-prone parts of Kubernetes. With Multi Tenant Operator, you can rest assured that RBAC is configured with the \"least privilege\" mindset and all rules are kept up-to-date with zero manual effort.</p> <p>Multi Tenant Operator binds existing ClusterRoles to the Tenant's Namespaces used for managing access to the Namespaces and the resources they contain. You can also modify the default roles or create new roles to have full control and customize access control for your users and teams.</p> <p>Multi Tenant Operator is also able to leverage existing OpenShift groups or external groups synced from 3rd party identity management systems, for maintaining Tenant membership in your organization's current user management system.</p>"},{"location":"introduction.html#hashicorp-vault-multitenancy","title":"HashiCorp Vault Multitenancy","text":"<p>Multi Tenant Operator extends the tenants permission model to HashiCorp Vault where it can create Vault paths and greatly ease the overhead of managing RBAC in Vault. Tenant users can manage their own secrets without the concern of someone else having access to their Vault paths.</p> <p>More details on Vault Multitenancy</p>"},{"location":"introduction.html#argocd-multitenancy","title":"ArgoCD Multitenancy","text":"<p>Multi Tenant Operator is not only providing strong Multi Tenancy for the OpenShift internals but also extends the tenants permission model to ArgoCD were it can provision AppProjects and Allowed Repositories for your tenants greatly ease the overhead of managing RBAC in ArgoCD.</p> <p>More details on ArgoCD Multitenancy</p>"},{"location":"introduction.html#mattermost-multitenancy","title":"Mattermost Multitenancy","text":"<p>Multi Tenant Operator can manage Mattermost to create Teams for tenant users. All tenant users get a unique team and a list of predefined channels gets created. When a user is removed from the tenant, the user is also removed from the Mattermost team corresponding to tenant.</p> <p>More details on Mattermost</p>"},{"location":"introduction.html#costresource-optimization","title":"Cost/Resource Optimization","text":"<p>Multi Tenant Operator provides a mechanism for defining Resource Quotas at the tenant scope, meaning all namespaces belonging to a particular tenant share the defined quota, which is why you are able to safely enable dev teams to self serve their namespaces whilst being confident that they can only use the resources allocated based on budget and business needs.</p> <p>More details on Quota</p>"},{"location":"introduction.html#remote-development-namespaces","title":"Remote Development Namespaces","text":"<p>Multi Tenant Operator can be configured to automatically provision a namespace in the cluster for every member of the specific tenant, that will also be preloaded with any selected templates and consume the same pool of resources from the tenants quota creating safe remote dev namespaces that teams can use as scratch namespace for rapid prototyping and development. So, every developer gets a Kubernetes-based cloud development environment that feel like working on localhost.</p> <p>More details on Sandboxes</p>"},{"location":"introduction.html#templates-and-template-distribution","title":"Templates and Template distribution","text":"<p>Multi Tenant Operator allows admins/users to define templates for namespaces, so that others can instantiate these templates to provision namespaces with batteries loaded. A template could pre-populate a namespace for certain use cases or with basic tooling required. Templates allow you to define Kubernetes manifests, Helm chart and more to be applied when the template is used to create a namespace.</p> <p>It also allows the parameterizing of these templates for flexibility and ease of use. It also provides the option to enforce the presence of templates in one tenant's or all the tenants' namespaces for configuring secure defaults.</p> <p>Common use cases for namespace templates may be:</p> <ul> <li>Adding networking policies for multitenancy</li> <li>Adding development tooling to a namespace</li> <li>Deploying pre-populated databases with test data</li> <li>Injecting new namespaces with optional credentials such as image pull secrets</li> </ul> <p>More details on Distributing Template Resources</p>"},{"location":"introduction.html#hibernation","title":"Hibernation","text":"<p>Multi Tenant Operator can downscale Deployments and StatefulSets in a tenant's Namespace according to a defined  sleep schedule. The Deployments and StatefulSets are brought back to their required replicas according to the provided wake schedule.</p> <p>More details on Hibernation</p>"},{"location":"introduction.html#cross-namespace-resource-distribution","title":"Cross Namespace Resource Distribution","text":"<p>Multi Tenant Operator supports cloning of secrets and configmaps from one namespace to another namespace based on label selectors. It uses templates to enable users to provide reference to secrets and configmaps. It uses a template group instance to distribute those secrets and namespaces in matching namespaces, even if namespaces belong to different tenants. If template instance is used then the resources will only be mapped if namespaces belong to same tenant.</p> <p>More details on Distributing Secrets and ConfigMaps</p>"},{"location":"introduction.html#self-service","title":"Self-Service","text":"<p>With Multi Tenant Operator, you can empower your users to safely provision namespaces for themselves and their teams (typically mapped to SSO groups). Team-owned namespaces and the resources inside them count towards the team's quotas rather than the user's individual limits and are automatically shared with all team members according to the access rules you configure in Multi Tenant Operator.</p> <p>Also, by leveraging Multi Tenant Operator's templating mechanism, namespaces can be provisioned and automatically pre-populated with any kind of resource or multiple resources such as network policies, docker pull secrets or even Helm charts etc</p>"},{"location":"introduction.html#everything-as-codegitops-ready","title":"Everything as Code/GitOps Ready","text":"<p>Multi Tenant Operator is designed and built to be 100% OpenShift-native and to be configured and managed the same familiar way as native OpenShift resources so is perfect for modern shops that are dedicated to GitOps as it is fully configurable using Custom Resources.</p>"},{"location":"introduction.html#preventing-clusters-sprawl","title":"Preventing Clusters Sprawl","text":"<p>As companies look to further harness the power of cloud-native, they are adopting container technologies at rapid speed, increasing the number of clusters and workloads. As the number of Kubernetes clusters grows, this is an increasing work for the Ops team. When it comes to patching security issues or upgrading clusters, teams are doing five times the amount of work.</p> <p>With Multi Tenant Operator teams can share a single cluster with multiple teams, groups of users, or departments by saving operational and management efforts. This prevents you from Kubernetes cluster sprawl.</p>"},{"location":"introduction.html#native-experience","title":"Native Experience","text":"<p>Multi Tenant Operator provides multi-tenancy with a native Kubernetes experience without introducing additional management layers, plugins, or customized binaries.</p>"},{"location":"tenant-roles.html","title":"Tenant Member Roles","text":"<p>After adding support for custom roles within MTO, this page is only applicable if you use OpenShift and its default <code>owner</code>, <code>edit</code>, and <code>view</code> roles. For more details, see the IntegrationConfig spec</p> <p>MTO tenant members can have one of following 3 roles:</p> <ol> <li>Owner</li> <li>Editor</li> <li>Viewer</li> </ol>"},{"location":"tenant-roles.html#1-owner","title":"1. Owner","text":"<p> fig 2. Shows how tenant owners manage their tenant using MTO</p> <p>Owner is an admin of a tenant with some restrictions. It has privilege to see all resources in their Tenant with some additional privileges. They can also create new <code>namespaces</code>.</p> <p>Owners will also inherit roles from <code>Edit</code> and <code>View</code>.</p>"},{"location":"tenant-roles.html#access-permissions","title":"Access Permissions","text":"<ul> <li>Role and RoleBinding access in <code>Project</code> :<ul> <li>delete</li> <li>create</li> <li>list</li> <li>get</li> <li>update</li> <li>patch</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#quotas-permissions","title":"Quotas Permissions","text":"<ul> <li> <p>LimitRange and ResourceQuota access in <code>Project</code></p> <ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> <li> <p>Daemonset access in <code>Project</code></p> <ul> <li>create</li> <li>delete</li> <li>get</li> <li>list</li> <li>patch</li> <li>update</li> <li>watch</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#resources-permissions","title":"Resources Permissions","text":"<ul> <li>CRUD access on Template, TemplateInstance and TemplateGroupInstance of MTO custom resources</li> <li>CRUD access on ImageStreamTags in <code>Project</code></li> <li>Get access on CustomResourceDefinitions in <code>Project</code></li> <li>Get, list, watch access on Builds, BuildConfigs in <code>Project</code></li> <li>CRUD access on following resources in <code>Project</code>:<ul> <li>Prometheuses</li> <li>Prometheusrules</li> <li>ServiceMonitors</li> <li>PodMonitors</li> <li>ThanosRulers</li> </ul> </li> <li>Permission to create Namespaces.</li> <li>Restricted to perform actions on cluster resource Quotas and Limits.</li> </ul>"},{"location":"tenant-roles.html#2-editor","title":"2. Editor","text":"<p> fig 3. Shows editors role in a tenant using MTO</p> <p>Edit role will have edit access on their <code>Projects</code>, but they wont have access on <code>Roles</code> or <code>RoleBindings</code>.</p> <p>Editors will also inherit <code>View</code> role.</p>"},{"location":"tenant-roles.html#access-permissions_1","title":"Access Permissions","text":"<ul> <li>ServiceAccount access in <code>Project</code><ul> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>get</li> <li>list</li> <li>patch</li> <li>update</li> <li>watch</li> <li>impersonate</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#quotas-permissions_1","title":"Quotas Permissions","text":"<ul> <li>AppliedClusterResourceQuotas and ResourceQuotaUsages access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#builds-pods-pvc-permissions","title":"Builds ,Pods , PVC Permissions","text":"<ul> <li>Pod, PodDisruptionBudgets and PVC access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>patch</li> <li>update</li> </ul> </li> <li>Build, BuildConfig, BuildLog, DeploymentConfig, Deployment, ConfigMap, ImageStream , ImageStreamImage and ImageStreamMapping access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>patch</li> <li>update</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#resources-permissions_1","title":"Resources Permissions","text":"<ul> <li>CRUD access on Template, TemplateInstance and TemplateGroupInstance of MTO custom resources</li> <li>Job, CronJob, Task, Trigger and Pipeline access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>patch</li> <li>update</li> </ul> </li> <li>Get access on projects</li> <li>Route and NetworkPolicies access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>patch</li> <li>update</li> </ul> </li> <li>Template, ReplicaSet, StatefulSet and DaemonSet access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>patch</li> <li>update</li> </ul> </li> <li>CRUD access on all Projects related to<ul> <li>Elasticsearch</li> <li>Logging</li> <li>Kibana</li> <li>Istio</li> <li>Jaeger</li> <li>Kiali</li> <li>Tekton.dev</li> </ul> </li> <li>Get access on CustomResourceDefinitions in <code>Project</code></li> <li>Edit and view permission on <code>jenkins.build.openshift.io</code></li> <li>InstallPlan access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>delete</li> </ul> </li> <li>Subscription and PackageManifest access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> <li>create</li> <li>delete</li> <li>deletecollection</li> <li>patch</li> <li>update</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#3-viewer","title":"3. Viewer","text":"<p> fig 4. Shows viewers role in a tenant using MTO</p> <p>Viewer role will only have view access on their <code>Project</code>.</p>"},{"location":"tenant-roles.html#access-permissions_2","title":"Access Permissions","text":"<ul> <li>ServiceAccount access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#quotas-permissions_2","title":"Quotas Permissions","text":"<ul> <li>AppliedClusterResourceQuotas access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#builds-pods-pvc-permissions_1","title":"Builds ,Pods , PVC Permissions","text":"<ul> <li>Pod, PodDisruptionBudget and PVC access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> <li>Build, BuildConfig, BuildLog, DeploymentConfig, ConfigMap, ImageStream, ImageStreamImage and ImageStreamMapping access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> </ul>"},{"location":"tenant-roles.html#resources-permissions_2","title":"Resources Permissions","text":"<ul> <li>Get, list, view access on Template, TemplateInstance and TemplateGroupInstance of MTO custom resources</li> <li>Job, CronJob, Task, Trigger and Pipeline access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> <li>Get access on projects</li> <li>Routes, NetworkPolicies and Daemonset access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> <li>Template, ReplicaSet, StatefulSet and Daemonset in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> <li>Get,list,watch access on all projects related to<ul> <li>Elasticsearch</li> <li>Logging</li> <li>Kibana</li> <li>Istio</li> <li>Jaeger</li> <li>Kiali</li> <li>Tekton.dev</li> </ul> </li> <li>Get, list, watch access on ImageStream, ImageStreamImage and ImageStreamMapping in <code>Project</code></li> <li>Get access on CustomResourceDefinition in <code>Project</code></li> <li>View permission on <code>Jenkins.Build.Openshift.io</code></li> <li>Subscription, PackageManifest and InstallPlan access in <code>Project</code><ul> <li>get</li> <li>list</li> <li>watch</li> </ul> </li> </ul>"},{"location":"troubleshooting.html","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting.html#operatorhub-upgrade-error","title":"OperatorHub Upgrade Error","text":""},{"location":"troubleshooting.html#operator-is-stuck-in-upgrade-if-upgrade-approval-is-set-to-automatic","title":"Operator is stuck in upgrade if upgrade approval is set to Automatic","text":""},{"location":"troubleshooting.html#problem","title":"Problem","text":"<p>If operator upgrade is set to Automatic Approval on OperatorHub, there may be scenarios where it gets blocked.</p>"},{"location":"troubleshooting.html#resolution","title":"Resolution","text":"<p>Information<p>If upgrade approval is set to manual, and you want to skip upgrade of a specific version, then delete the InstallPlan created for that specific version. Operator Lifecycle Manager (OLM) will create the latest available InstallPlan which can be approved then.</p> </p> <p>As OLM does not allow to upgrade or downgrade from a version stuck because of error, the only possible fix is to uninstall the operator from the cluster. When the operator is uninstalled it removes all of its resources i.e., ClusterRoles, ClusterRoleBindings, and Deployments etc., except Custom Resource Definitions (CRDs), so none of the Custom Resources (CRs), Tenants, Templates etc., will be removed from the cluster. If any CRD has a conversion webhook defined then that webhook should be removed before installing the stable version of the operator. This can be achieved via removing the <code>.spec.conversion</code> block from the CRD schema.</p> <p>As an example, if you have installed v0.8.0 of Multi Tenant Operator on your cluster, then it'll stuck in an error <code>error validating existing CRs against new CRD's schema for \"integrationconfigs.tenantoperator.stakater.com\": error validating custom resource against new schema for IntegrationConfig multi-tenant-operator/tenant-operator-config: [].spec.tenantRoles: Required value</code>. To resolve this issue, you'll first uninstall the MTO from the cluster. Once you uninstall the MTO, check Tenant CRD which will have a conversion block, which needs to be removed. After removing the conversion block from the Tenant CRD, install the latest available version of MTO from OperatorHub.</p>"},{"location":"troubleshooting.html#permission-issues","title":"Permission Issues","text":""},{"location":"troubleshooting.html#vault-user-permissions-are-not-updated-if-the-user-is-added-to-a-tenant-and-the-user-does-not-exist-in-rhsso","title":"Vault user permissions are not updated if the user is added to a Tenant, and the user does not exist in RHSSO","text":""},{"location":"troubleshooting.html#problem_1","title":"Problem","text":"<p>If a user is added to tenant resource, and the user does not exist in RHSSO, then RHSSO is not updated with the user's Vault permission.</p>"},{"location":"troubleshooting.html#reproduction-steps","title":"Reproduction steps","text":"<ol> <li>Add a new user to Tenant CR</li> <li>Attempt to log in to Vault with the added user</li> <li>Vault denies that the user exists, and signs the user up via RHSSO. User is now created on RHSSO (you may check for the user on RHSSO).</li> </ol>"},{"location":"troubleshooting.html#resolution_1","title":"Resolution","text":"<p>If the user does not exist in RHSSO, then MTO does not create the tenant access for Vault in RHSSO.</p> <p>The user now needs to go to Vault, and sign up using OIDC. Then the user needs to wait for MTO to reconcile the updated tenant (reconciliation period is currently 1 hour). After reconciliation, MTO will add relevant access for the user in RHSSO.</p> <p>If the user needs to be added immediately and it is not feasible to wait for next MTO reconciliation, then: add a label or annotation to the user, or restart the Tenant controller pod to force immediate reconciliation.</p>"},{"location":"vault-multitenancy.html","title":"Vault Multitenancy","text":"<p>HashiCorp Vault is an identity-based secret and encryption management system. Vault validates and authorizes a system's clients (users, machines, apps) before providing them access to secrets or stored sensitive data.</p>"},{"location":"vault-multitenancy.html#vault-integration-in-multi-tenant-operator","title":"Vault integration in Multi Tenant Operator","text":""},{"location":"vault-multitenancy.html#service-account-auth-in-vault","title":"Service Account Auth in Vault","text":"<p>MTO enables the Kubernetes auth method which can be used to authenticate with Vault using a Kubernetes Service Account Token. When enabled, for every tenant namespace, MTO automatically creates policies and roles that allow the service accounts present in those namespaces to read secrets at tenant's path in Vault. The name of the role is the same as namespace name.</p> <p>These service accounts are required to have <code>stakater.com/vault-access: true</code> label, so they can be authenticated with Vault via MTO.</p> <p>The Diagram shows how MTO enables ServiceAccounts to read secrets from Vault.</p> <p></p>"},{"location":"vault-multitenancy.html#user-oidc-auth-in-vault","title":"User OIDC Auth in Vault","text":"<p>This requires a running <code>RHSSO(RedHat Single Sign On)</code> instance integrated with Vault over OIDC login method.</p> <p>MTO integration with Vault and RHSSO provides a way for users to log in to Vault where they only have access to relevant tenant paths.</p> <p>Once both integrations are set-up with IntegrationConfig CR, MTO links tenant users to specific client roles named after their tenant under Vault client in RHSSO.</p> <p>After that, MTO creates specific policies in Vault for its tenant users.</p> <p>Mapping of tenant roles to Vault is shown below</p> Tenant Role Vault Path Vault Capabilities Owner, Editor (tenantName)/* Create, Read, Update, Delete, List Owner, Editor sys/mounts/(tenantName)/* Create, Read, Update, Delete, List Owner, Editor managed-addons/* Read, List Viewer (tenantName)/* Read <p>A simple user login workflow is shown in the diagram below.</p> <p></p>"},{"location":"explanation/why-argocd-multi-tenancy.html","title":"Need for Multi-Tenancy in ArgoCD","text":""},{"location":"explanation/why-argocd-multi-tenancy.html#argocd-multi-tenancy","title":"ArgoCD Multi-tenancy","text":"<p>ArgoCD is a declarative GitOps tool built to deploy applications to Kubernetes. While the continuous delivery (CD) space is seen by some as crowded these days, ArgoCD does bring some interesting capabilities to the table. Unlike other tools, ArgoCD is lightweight and easy to configure.</p>"},{"location":"explanation/why-argocd-multi-tenancy.html#why-argocd","title":"Why ArgoCD?","text":"<p>Application definitions, configurations, and environments should be declarative and version controlled. Application deployment and lifecycle management should be automated, auditable, and easy to understand.</p>"},{"location":"explanation/why-vault-multi-tenancy.html","title":"Need for Multi-Tenancy in Vault","text":""},{"location":"faq/index.html","title":"Index","text":""},{"location":"how-to-guides/integration-config.html","title":"Integration Config","text":"<p>IntegrationConfig is used to configure settings of multi-tenancy for Multi Tenant Operator.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\ntenantRoles:\ndefault:\nowner:\nclusterRoles:\n- admin\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\n- viewer\ncustom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/kind\noperator: In\nvalues:\n- build\nmatchLabels:\nstakater.com/kind: dev\nowner:\nclusterRoles:\n- custom-owner\neditor:\nclusterRoles:\n- custom-editor\nviewer:\nclusterRoles:\n- custom-viewer\n- custom-view\nopenshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\ngroup:\nlabels:\nrole: customer-reader\nsandbox:\nlabels:\nstakater.com/kind: sandbox\nclusterAdminGroups:\n- cluster-admins\nprivilegedNamespaces:\n- ^default$\n- ^openshift-*\n- ^kube-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\nnamespaceAccessPolicy:\ndeny:\nprivilegedNamespaces:\nusers:\n- system:serviceaccount:openshift-argocd:argocd-application-controller\n- adam@stakater.com\ngroups:\n- cluster-admins\nargocd:\nnamespace: openshift-operators\nnamespaceResourceBlacklist:\n- group: '' # all groups\nkind: ResourceQuota\nclusterResourceWhitelist:\n- group: tronador.stakater.com\nkind: EnvironmentProvisioner\nrhsso:\nenabled: true\nrealm: customer\nendpoint:\nurl: https://iam-keycloak-auth.apps.prod.abcdefghi.kubeapp.cloud/\nsecretReference:\nname: auth-secrets\nnamespace: openshift-auth\nvault:\nenabled: true\nendpoint:\nurl: https://vault.apps.prod.abcdefghi.kubeapp.cloud/\nsecretReference:\nname: vault-root-token\nnamespace: vault\nsso:\nclientName: vault\naccessorID: &lt;ACCESSOR_ID_TOKEN&gt;\n</code></pre> <p>Following are the different components that can be used to configure multi-tenancy in a cluster via Multi Tenant Operator.</p>"},{"location":"how-to-guides/integration-config.html#tenantroles","title":"TenantRoles","text":"<p>TenantRoles are required within the IntegrationConfig, as they are used for defining what roles will be applied to each Tenant namespace. The field allows optional custom roles, that are then used to create RoleBindings for namespaces that match a labelSelector.</p> <p>\u26a0\ufe0f If you do not configure roles in any way, then the default OpenShift roles of <code>owner</code>, <code>edit</code>, and <code>view</code> will apply to Tenant members. Their details can be found here</p> <pre><code>tenantRoles:\ndefault:\nowner:\nclusterRoles:\n- admin\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\n- viewer\ncustom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/kind\noperator: In\nvalues:\n- build\nmatchLabels:\nstakater.com/kind: dev\nowner:\nclusterRoles:\n- custom-owner\neditor:\nclusterRoles:\n- custom-editor\nviewer:\nclusterRoles:\n- custom-viewer\n- custom-view\n</code></pre>"},{"location":"how-to-guides/integration-config.html#default","title":"Default","text":"<p>This field contains roles that will be used to create default roleBindings for each namespace that belongs to tenants. These roleBindings are only created for a namespace if that namespace isn't already matched by the <code>custom</code> field below it. Therefore, it is required to have at least one role mentioned within each of its three subfields: <code>owner</code>, <code>editor</code>, and <code>viewer</code>. These 3 subfields also correspond to the member fields of the Tenant CR</p>"},{"location":"how-to-guides/integration-config.html#custom","title":"Custom","text":"<p>An array of custom roles. Similar to the <code>default</code> field, you can mention roles within this field as well. However, the custom roles also require the use of a <code>labelSelector</code> for each iteration within the array. The roles mentioned here will only apply to the namespaces that are matched by the labelSelector. If a namespace is matched by 2 different labelSelectors, then both roles will apply to it. Additionally, roles can be skipped within the labelSelector. These missing roles are then inherited from the <code>default</code> roles field . For example, if the following custom roles arrangement is used:</p> <pre><code>custom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/kind\noperator: In\nvalues:\n- build\nmatchLabels:\nstakater.com/kind: dev\nowner:\nclusterRoles:\n- custom-owner\n</code></pre> <p>Then the <code>editor</code> and <code>viewer</code> roles will be taken from the <code>default</code> roles field, as that is required to have at least one role mentioned.</p>"},{"location":"how-to-guides/integration-config.html#openshift","title":"OpenShift","text":"<pre><code>openshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\ngroup:\nlabels:\nrole: customer-reader\nsandbox:\nlabels:\nstakater.com/kind: sandbox\nclusterAdminGroups:\n- cluster-admins\nprivilegedNamespaces:\n- ^default$\n- ^openshift-*\n- ^kube-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\nnamespaceAccessPolicy:\ndeny:\nprivilegedNamespaces:\nusers:\n- system:serviceaccount:openshift-argocd:argocd-application-controller\n- adam@stakater.com\ngroups:\n- cluster-admins\n</code></pre>"},{"location":"how-to-guides/integration-config.html#project-group-and-sandbox","title":"Project, group and sandbox","text":"<p>We can use the <code>openshift.project</code>, <code>openshift.group</code> and <code>openshift.sandbox</code> fields to automatically add <code>labels</code> and <code>annotations</code> to  the Projects and Groups managed via MTO.</p> <pre><code>  openshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\ngroup:\nlabels:\nrole: customer-reader\nsandbox:\nlabels:\nstakater.com/kind: sandbox\n</code></pre> <p>If we want to add default labels/annotations to sandbox namespaces of tenants than we just simply add them in <code>openshift.project.labels</code>/<code>openshift.project.annotations</code> respectively.</p> <p>Whenever a project is made it will have the labels and annotations as mentioned above.</p> <pre><code>kind: Project\napiVersion: project.openshift.io/v1\nmetadata:\nname: bluesky-build\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\nlabels:\nworkload-monitoring: 'true'\nstakater.com/tenant: bluesky\nspec:\nfinalizers:\n- kubernetes\nstatus:\nphase: Active\n</code></pre> <pre><code>kind: Group\napiVersion: user.openshift.io/v1\nmetadata:\nname: bluesky-owner-group\nlabels:\nrole: customer-reader\nusers:\n- andrew@stakater.com\n</code></pre>"},{"location":"how-to-guides/integration-config.html#cluster-admin-groups","title":"Cluster Admin Groups","text":"<p><code>clusterAdminGroups:</code> Contains names of the groups that are allowed to perform CRUD operations on namespaces present on the cluster. Users in the specified group(s) will be able to perform these operations without MTO getting in their way</p>"},{"location":"how-to-guides/integration-config.html#privileged-namespaces","title":"Privileged Namespaces","text":"<p><code>privilegedNamespaces:</code> Contains the list of <code>namespaces</code> ignored by MTO. MTO will not manage the <code>namespaces</code> in this list. Values in this list are regex patterns. For example:</p> <ul> <li>To ignore the <code>default</code> namespace, we can specify <code>^default$</code></li> <li>To ignore all namespaces starting with the <code>openshift-</code> prefix, we can specify <code>^openshift-*</code>.</li> <li>To ignore any namespace containing <code>stakater</code> in its name, we can specify <code>stakater</code>. (A constant word given as a regex pattern will match any namespace containing that word.)</li> </ul>"},{"location":"how-to-guides/integration-config.html#privileged-serviceaccounts","title":"Privileged ServiceAccounts","text":"<p><code>privilegedServiceAccounts:</code> Contains the list of <code>ServiceAccounts</code> ignored by MTO. MTO will not manage the <code>ServiceAccounts</code> in this list. Values in this list are regex patterns. For example, to ignore all <code>ServiceAccounts</code> starting with the <code>system:serviceaccount:openshift-</code> prefix, we can use <code>^system:serviceaccount:openshift-*</code>; and to ignore the <code>system:serviceaccount:builder</code> service account we can use <code>^system:serviceaccount:builder$.</code></p>"},{"location":"how-to-guides/integration-config.html#namespace-access-policy","title":"Namespace Access Policy","text":"<p><code>namespaceAccessPolicy.Deny:</code> Can be used to restrict privileged users/groups CRUD operation over managed namespaces.</p> <pre><code>namespaceAccessPolicy:\ndeny:\nprivilegedNamespaces:\ngroups:\n- cluster-admins\nusers:\n- system:serviceaccount:openshift-argocd:argocd-application-controller\n- adam@stakater.com\n</code></pre> <p>\u26a0\ufe0f If you want to use a more complex regex pattern (for the <code>openshift.privilegedNamespaces</code> or <code>openshift.privilegedServiceAccounts</code> field), it is recommended that you test the regex pattern first -  either locally or using a platform such as https://regex101.com/.</p>"},{"location":"how-to-guides/integration-config.html#argocd","title":"ArgoCD","text":""},{"location":"how-to-guides/integration-config.html#namespace","title":"Namespace","text":"<p><code>argocd.namespace</code> is an optional field used to specify the namespace where ArgoCD Applications and AppProjects are deployed. The field should be populated when you want to create an ArgoCD AppProject for each tenant.</p>"},{"location":"how-to-guides/integration-config.html#namespaceresourceblacklist","title":"NamespaceResourceBlacklist","text":"<pre><code>argocd:\nnamespaceResourceBlacklist:\n- group: '' # all resource groups\nkind: ResourceQuota\n- group: ''\nkind: LimitRange\n- group: ''\nkind: NetworkPolicy\n</code></pre> <p><code>argocd.namespaceResourceBlacklist</code> prevents ArgoCD from syncing the listed resources from your GitOps repo.</p>"},{"location":"how-to-guides/integration-config.html#clusterresourcewhitelist","title":"ClusterResourceWhitelist","text":"<pre><code>argocd:\nclusterResourceWhitelist:\n- group: tronador.stakater.com\nkind: EnvironmentProvisioner\n</code></pre> <p><code>argocd.clusterResourceWhitelist</code> allows ArgoCD to sync the listed cluster scoped resources from your GitOps repo.</p>"},{"location":"how-to-guides/integration-config.html#rhsso-red-hat-single-sign-on","title":"RHSSO (Red Hat Single Sign-On)","text":"<p>Red Hat Single Sign-On RHSSO is based on the Keycloak project and enables you to secure your web applications by providing Web single sign-on (SSO) capabilities based on popular standards such as SAML 2.0, OpenID Connect and OAuth 2.0.</p> <p>If <code>RHSSO</code> is configured on a cluster, then RHSSO configuration can be enabled.</p> <pre><code>rhsso:\nenabled: true\nrealm: customer\nendpoint:\nsecretReference:\nname: auth-secrets\nnamespace: openshift-auth\nurl: https://iam-keycloak-auth.apps.prod.abcdefghi.kubeapp.cloud/\n</code></pre> <p>If enabled, then admins have to provide secret and URL of RHSSO.</p> <ul> <li><code>secretReference.name:</code> Will contain the name of the secret.</li> <li><code>secretReference.namespace:</code> Will contain the namespace of the secret.</li> <li><code>realm:</code> Will contain the realm name which is configured for users.</li> <li><code>url:</code> Will contain the URL of RHSSO.</li> </ul>"},{"location":"how-to-guides/integration-config.html#vault","title":"Vault","text":"<p>Vault is used to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.</p> <p>If <code>vault</code> is configured on a cluster, then Vault configuration can be enabled.</p> <pre><code>Vault:\nenabled: true\nendpoint:\nsecretReference:\nname: vault-root-token\nnamespace: vault\nurl: &gt;-\nhttps://vault.apps.prod.abcdefghi.kubeapp.cloud/\nsso:\naccessorID: &lt;ACCESSOR_ID_TOKEN&gt;\nclientName: vault\n</code></pre> <p>If enabled, then admins have to provide secret, URL and SSO accessorID of Vault.</p> <ul> <li><code>secretReference.name:</code> Will contain the name of the secret.</li> <li><code>secretReference.namespace:</code> Will contain the namespace of the secret.</li> <li><code>url:</code> Will contain the URL of Vault.</li> <li><code>sso.accessorID:</code> Will contain the SSO accessorID.</li> <li><code>sso.clientName:</code> Will contain the client name.</li> </ul> <p>For more details please refer use-cases</p>"},{"location":"how-to-guides/quota.html","title":"Quota","text":"<p>Using Multi Tenant Operator, the cluster-admin can set and enforce cluster resource quotas and limit ranges for tenants.</p>"},{"location":"how-to-guides/quota.html#assigning-resource-quotas","title":"Assigning Resource Quotas","text":"<p>Bill is a cluster admin who will first create <code>Quota</code> CR where he sets the maximum resource limits that Anna's tenant will have. Here <code>limitrange</code> is an optional field, cluster admin can skip it if not needed.</p> <p>The annotation <code>quota.tenantoperator.stakater.com/is-default: \"true\"</code> sets the quota as default quota.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nannotations:\nquota.tenantoperator.stakater.com/is-default: \"false\"\nname: small\nspec:\nresourcequota:\nhard:\nrequests.cpu: '5'\nrequests.memory: '5Gi'\nconfigmaps: \"10\"\nsecrets: \"10\"\nservices: \"10\"\nservices.loadbalancers: \"2\"\nlimitrange:\nlimits:\n- type: \"Pod\"\nmax:\ncpu: \"2\"\nmemory: \"1Gi\"\nmin:\ncpu: \"200m\"\nmemory: \"100Mi\"\nEOF\n</code></pre> <p>For more details please refer to Quotas.</p> <pre><code>kubectl get quota small\nNAME       STATE    AGE\nsmall      Active   3m\n</code></pre> <p>Bill then proceeds to create a tenant for Anna, while also linking the newly created <code>Quota</code>.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@stakater.com\nquota: small\nsandbox: false\nEOF\n</code></pre> <p>When no quota is mentioned in the <code>quota</code> field of Tenant CR, MTO looks for quota with the following annotation <code>quota.tenantoperator.stakater.com/is-default: \"true\"</code> and links that quota with the tenant.</p> <p>Now that the quota is linked with Anna's tenant, Anna can create any resource within the values of resource quota and limit range.</p> <pre><code>kubectl -n bluesky-production create deployment nginx --image nginx:latest --replicas 4\n</code></pre> <p>Once the resource quota assigned to the tenant has been reached, Anna cannot create further resources.</p> <pre><code>kubectl create pods bluesky-training\nError from server (Cannot exceed Namespace quota: please, reach out to the system administrators)\n</code></pre>"},{"location":"how-to-guides/quota.html#limiting-persistentvolume-for-tenant","title":"Limiting PersistentVolume for Tenant","text":"<p>Bill, as a cluster admin, wants to restrict the amount of storage a Tenant can use. For that he'll add the <code>requests.storage</code> field to <code>quota.spec.resourcequota.hard</code>. If Bill wants to restrict tenant <code>bluesky</code> to use only <code>50Gi</code> of storage, he'll first create a quota with <code>requests.storage</code> field set to <code>50Gi</code>.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nname: medium\nspec:\nresourcequota:\nhard:\nrequests.cpu: '5'\nrequests.memory: '10Gi'\nrequests.storage: '50Gi'\n</code></pre> <p>Once the quota is created, Bill will create the tenant and set the quota field to the one he created.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\nquota: medium\nsandbox: true\nEOF\n</code></pre> <p>Now, the combined storage used by all tenant namespaces will not exceed <code>50Gi</code>.</p>"},{"location":"how-to-guides/quota.html#adding-storageclass-restrictions-for-tenant","title":"Adding StorageClass Restrictions for Tenant","text":"<p>Now, Bill, as a cluster admin, wants to make sure that no Tenant can provision more than a fixed amount of storage from a StorageClass. Bill can restrict that using <code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage</code> field in <code>quota.spec.resourcequota.hard</code> field. If Bill wants to restrict tenant <code>sigma</code> to use only <code>20Gi</code> of storage from storage class <code>stakater</code>, he'll first create a StorageClass <code>stakater</code> and then create the relevant Quota with <code>stakater.storageclass.storage.k8s.io/requests.storage</code> field set to <code>20Gi</code>.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nname: small\nspec:\nresourcequota:\nhard:\nrequests.cpu: '2'\nrequests.memory: '4Gi'\nstakater.storageclass.storage.k8s.io/requests.storage: '20Gi'\n</code></pre> <p>Once the quota is created, Bill will create the tenant and set the quota field to the one he created.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nspec:\nowners:\nusers:\n- dave@aurora.org\nquota: small\nsandbox: true\nEOF\n</code></pre> <p>Now, the combined storage provisioned from StorageClass <code>stakater</code> used by all tenant namespaces will not exceed <code>20Gi</code>.</p> <p>The <code>20Gi</code> limit will only be applied to StorageClass <code>stakater</code>. If a tenant member creates a PVC with some other StorageClass, he will not be restricted.</p> <p>Tip</p> <p>More details about <code>Resource Quota</code> can be found here</p>"},{"location":"how-to-guides/template-group-instance.html","title":"TemplateGroupInstance","text":"<p>Cluster scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: namespace-parameterized-restrictions-tgi\nspec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\n- beta\nparameters:\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\n</code></pre> <p>TemplateGroupInstance distributes a template across multiple namespaces which are selected by labelSelector.</p>"},{"location":"how-to-guides/template-instance.html","title":"TemplateInstance","text":"<p>Namespace scoped resource:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: networkpolicy\nnamespace: build\nspec:\ntemplate: networkpolicy\nsync: true\nparameters:\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\n</code></pre> <p>TemplateInstance are used to keep track of resources created from Templates, which are being instantiated inside a Namespace. Generally, a TemplateInstance is created from a Template and then the TemplateInstances will not be updated when the Template changes later on. To change this behavior, it is possible to set <code>spec.sync: true</code> in a TemplateInstance. Setting this option, means to keep this TemplateInstance in sync with the underlying template (similar to Helm upgrade).</p>"},{"location":"how-to-guides/template.html","title":"Template","text":""},{"location":"how-to-guides/template.html#cluster-scoped-resource","title":"Cluster scoped resource","text":"<pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: redis\nresources:\nhelm:\nreleaseName: redis\nchart:\nrepository:\nname: redis\nrepoUrl: https://charts.bitnami.com/bitnami\nvalues: |\nredisPort: 6379\n---\napiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: networkpolicy\nparameters:\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\nresources:\nmanifests:\n- kind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\nname: deny-cross-ns-traffic\nspec:\npodSelector:\nmatchLabels:\nrole: db\npolicyTypes:\n- Ingress\n- Egress\ningress:\n- from:\n- ipBlock:\ncidr: \"${{CIDR_IP}}\"\nexcept:\n- 172.17.1.0/24\n- namespaceSelector:\nmatchLabels:\nproject: myproject\n- podSelector:\nmatchLabels:\nrole: frontend\nports:\n- protocol: TCP\nport: 6379\negress:\n- to:\n- ipBlock:\ncidr: 10.0.0.0/24\nports:\n- protocol: TCP\nport: 5978\n---\napiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: resource-mapping\nresources:\nresourceMappings:\nsecrets:\n- name: secret-s1\nnamespace: namespace-n1\nconfigMaps:\n- name: configmap-c1\nnamespace: namespace-n2\n</code></pre> <p>Templates are used to initialize Namespaces, share common resources across namespaces, and map secrets/configmaps from one namespace to other namespaces.</p> <ul> <li>They either contain one or more Kubernetes manifests, a reference to secrets/configmaps, or a Helm chart.</li> <li>They are being tracked by TemplateInstances in each Namespace they are applied to.</li> <li>They can contain pre-defined parameters such as ${namespace}/${tenant} or user-defined ${MY_PARAMETER} that can be specified within an TemplateInstance.</li> </ul> <p>Also, you can define custom variables in <code>Template</code> and <code>TemplateInstance</code> . The parameters defined in <code>TemplateInstance</code> are overwritten the values defined in <code>Template</code> .</p> <p>Manifest Templates: The easiest option to define a Template is by specifying an array of Kubernetes manifests which should be applied when the Template is being instantiated.</p> <p>Helm Chart Templates: Instead of manifests, a Template can specify a Helm chart that will be installed (using Helm template) when the Template is being instantiated.</p> <p>Resource Mapping Templates: A template can be used to map secrets and configmaps from one tenant's namespace to another tenant's namespace, or within a tenant's namespace.</p>"},{"location":"how-to-guides/template.html#mandatory-and-optional-templates","title":"Mandatory and Optional Templates","text":"<p>Templates can either be mandatory or optional. By default, all Templates are optional. Cluster Admins can make Templates mandatory by adding them to the <code>spec.templateInstances</code> array within the Tenant configuration. All Templates listed in <code>spec.templateInstances</code> will always be instantiated within every <code>Namespace</code> that is created for the respective Tenant.</p>"},{"location":"how-to-guides/tenant.html","title":"Tenant","text":"<p>Cluster scoped resource:</p> <p>The smallest valid Tenant definition is given below (with just one field in its spec):</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: alpha\nspec:\nquota: small\n</code></pre> <p>Here is a more detailed Tenant definition, explained below:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: alpha\nspec:\nowners: # optional\nusers: # optional\n- dave@stakater.com\ngroups: # optional\n- alpha\neditors: # optional\nusers: # optional\n- jack@stakater.com\nviewers: # optional\nusers: # optional\n- james@stakater.com\nquota: medium # required\nsandboxConfig: # optional\nenabled: true # optional\nprivate: true # optional\nonDelete: # optional\ncleanNamespaces: false # optional\ncleanAppProject: true # optional\nargocd: # optional\nsourceRepos: # required\n- https://github.com/stakater/gitops-config\nappProject: # optional\nclusterResourceWhitelist: # optional\n- group: tronador.stakater.com\nkind: Environment\nnamespaceResourceBlacklist: # optional\n- group: \"\"\nkind: ConfigMap\nhibernation: # optional\nsleepSchedule: 23 * * * * # required\nwakeSchedule: 26 * * * * # required\nnamespaces: # optional\nwithTenantPrefix: # optional\n- dev\n- build\nwithoutTenantPrefix: # optional\n- preview\ncommonMetadata: # optional\nlabels: # optional\nstakater.com/team: alpha\nannotations: # optional\nopenshift.io/node-selector: node-role.kubernetes.io/infra=\nspecificMetadata: # optional\n- annotations: # optional\nstakater.com/user: dave\nlabels: # optional\nstakater.com/sandbox: true\nnamespaces: # optional\n- alpha-dave-stakater-sandbox\ntemplateInstances: # optional\n- spec: # optional\ntemplate: networkpolicy # required\nsync: true  # optional\nparameters: # optional\n- name: CIDR_IP\nvalue: \"172.17.0.0/16\"\nselector: # optional\nmatchLabels: # optional\npolicy: network-restriction\n</code></pre> <ul> <li> <p>Tenant has 3 kinds of <code>Members</code>. Each member type should have different roles assigned to them. These roles are gotten from the IntegrationConfig's TenantRoles field. You can customize these roles to your liking, but by default the following configuration applies:</p> <ul> <li><code>Owners:</code> Users who will be owners of a tenant. They will have OpenShift admin-role assigned to their users, with additional access to create namespaces as well.</li> <li><code>Editors:</code> Users who will be editors of a tenant. They will have OpenShift edit-role assigned to their users.</li> <li><code>Viewers:</code> Users who will be viewers of a tenant. They will have OpenShift view-role assigned to their users.</li> <li>For more details, check out their definitions.</li> </ul> </li> <li> <p><code>Users</code> can be linked to the tenant by specifying there username in <code>owners.users</code>, <code>editors.users</code> and <code>viewers.users</code> respectively.</p> </li> <li> <p><code>Groups</code> can be linked to the tenant by specifying the group name in <code>owners.groups</code>, <code>editors.groups</code> and <code>viewers.groups</code> respectively.</p> </li> <li> <p>Tenant will have a <code>Quota</code> to limit resource consumption.</p> </li> <li> <p><code>sandboxConfig</code> is used to configure the tenant user sandbox feature</p> <ul> <li>Setting <code>enabled</code> to true will create sandbox namespaces for owners and editors.</li> <li>Sandbox will follow the following naming convention {TenantName}-{UserName}-sandbox.</li> <li>In case of groups, the sandbox namespaces will be created for each member of the group.</li> <li>Setting <code>private</code> to true will make those sandboxes be only visible to the user they belong to. By default, sandbox namespaces are visible to all tenant members</li> </ul> </li> <li> <p><code>onDelete</code> is used to tell Multi Tenant Operator what to do when a Tenant is deleted.</p> <ul> <li><code>cleanNamespaces</code> if the value is set to true MTO deletes all tenant namespaces when a <code>Tenant</code> is deleted. Default value is false.</li> <li><code>cleanAppProject</code> will keep the generated ArgoCD AppProject if the value is set to false. By default, the value is true.</li> </ul> </li> <li> <p><code>argocd</code> is required if you want to create an ArgoCD AppProject for the tenant.</p> <ul> <li><code>sourceRepos</code> contain a list of repositories that point to your GitOps.</li> <li><code>appProject</code> is used to set the <code>clusterResourceWhitelist</code> and <code>namespaceResourceBlacklist</code> resources. If these are also applied via <code>IntegrationConfig</code> then those applied via Tenant CR will have higher precedence for given Tenant.</li> </ul> </li> <li> <p><code>hibernation</code> can be used to create a schedule during which the namespaces belonging to the tenant will be put to sleep. The values of the <code>sleepSchedule</code> and <code>wakeSchedule</code> fields must be a string in a cron format.</p> </li> <li> <p>Namespaces can also be created via tenant CR by specifying names in <code>namespaces</code>.</p> <ul> <li>Multi Tenant Operator will append tenant name prefix while creating namespaces if the list of namespaces is under the <code>withTenantPrefix</code> field, so the format will be {TenantName}-{Name}.</li> <li>Namespaces listed under the <code>withoutTenantPrefix</code> will be created with the given name. Writing down namespaces here that already exist within the cluster are not allowed.</li> <li><code>stakater.com/kind: {Name}</code> label will also be added to the namespaces.</li> </ul> </li> <li> <p><code>commonMetadata</code> can be used to distribute common labels and annotations among tenant namespaces.</p> <ul> <li><code>labels</code> distributes provided labels among all tenant namespaces</li> <li><code>annotations</code> distributes provided annotations among all tenant namespaces</li> </ul> </li> <li> <p><code>specificMetadata</code> can be used to distribute specific labels and annotations among specific tenant namespaces.</p> <ul> <li><code>labels</code> distributes given labels among specific tenant namespaces</li> <li><code>annotations</code> distributes given annotations among specific tenant namespaces</li> <li><code>namespaces</code> consists a list of specific tenant namespaces across which the labels and annotations will be distributed</li> </ul> </li> <li> <p>Tenant automatically deploys <code>template</code> resource mentioned in <code>templateInstances</code> to matching tenant namespaces.</p> <ul> <li><code>Template</code> resources are created in those <code>namespaces</code> which belong to a <code>tenant</code> and contain <code>matching labels</code>.</li> <li><code>Template</code> resources are created in all <code>namespaces</code> of a <code>tenant</code> if <code>selector</code> field is empty.</li> </ul> </li> </ul> <p>\u26a0\ufe0f If same label or annotation key is being applied using different methods provided, then the highest precedence will be given to <code>specificMetadata</code> followed by <code>commonMetadata</code> and in the end would be the ones applied from <code>openshift.project.labels</code>/<code>openshift.project.annotations</code> in <code>IntegrationConfig</code></p>"},{"location":"how-to-guides/offboarding/uninstalling.html","title":"Uninstall via OperatorHub UI","text":"<p>You can uninstall MTO by following these steps:</p> <ul> <li> <p>Decide on whether you want to retain tenant namespaces and ArgoCD AppProjects or not. If yes, please set <code>spec.onDelete.cleanNamespaces</code> to <code>false</code> for all those tenants whose namespaces you want to retain, and <code>spec.onDelete.cleanAppProject</code> to <code>false</code> for all those tenants whose AppProject you want to retain. For more details check out onDelete</p> </li> <li> <p>After making the required changes open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu</p> </li> </ul> <p></p> <ul> <li>Now click on uninstall and confirm uninstall.</li> </ul> <p></p> <ul> <li> <p>Now the operator has been uninstalled.</p> </li> <li> <p><code>Optional:</code> you can also manually remove MTO's CRDs and its resources from the cluster.</p> </li> </ul>"},{"location":"how-to-guides/offboarding/uninstalling.html#notes","title":"Notes","text":"<ul> <li>For more details on how to use MTO please refer use-cases.</li> <li>For more details on how to extend your MTO manager ClusterRole please refer extend-admin-clusterrole.</li> </ul>"},{"location":"reference-guides/add-remove-namespace-gitops.html","title":"Add/Remove Namespace to Tenant via GitOps","text":""},{"location":"reference-guides/admin-clusterrole.html","title":"Extending Admin ClusterRole","text":"<p>Bill as the cluster admin want to add additional rules for admin ClusterRole.</p> <p>Bill can extend the <code>admin</code> role for MTO using the aggregation label for admin ClusterRole. Bill will create a new ClusterRole with all the permissions he needs to extend for MTO and add the aggregation label on the newly created ClusterRole.</p> <pre><code>kind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: extend-admin-role\nlabels:\nrbac.authorization.k8s.io/aggregate-to-admin: 'true'\nrules:\n- verbs:\n- create\n- update\n- patch\n- delete\napiGroups:\n- user.openshift.io\nresources:\n- groups\n</code></pre> <p>Note: You can learn more about <code>aggregated-cluster-roles</code> here</p>"},{"location":"reference-guides/admin-clusterrole.html#whats-next","title":"What\u2019s next","text":"<p>See how Bill can hibernate unused namespaces at night</p>"},{"location":"reference-guides/configuring-multitenant-network-isolation.html","title":"Configuring Multi-Tenant Isolation with Network Policy Template","text":"<p>Bill is a cluster admin who wants to configure network policies to provide multi-tenant network isolation.</p> <p>First, Bill creates a template for network policies:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: tenant-network-policy\nresources:\nmanifests:\n- apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-same-namespace\nspec:\npodSelector: {}\ningress:\n- from:\n- podSelector: {}\n- apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-from-openshift-monitoring\nspec:\ningress:\n- from:\n- namespaceSelector:\nmatchLabels:\nnetwork.openshift.io/policy-group: monitoring\npodSelector: {}\npolicyTypes:\n- Ingress\n- apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-from-openshift-ingress\nspec:\ningress:\n- from:\n- namespaceSelector:\nmatchLabels:\nnetwork.openshift.io/policy-group: ingress\npodSelector: {}\npolicyTypes:\n- Ingress\n</code></pre> <p>Once the template has been created, Bill edits the IntegrationConfig to add unique label to all tenant projects:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\ntenant-network-policy: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\nsandbox:\nlabels:\nstakater.com/kind: sandbox\nprivilegedNamespaces:\n- default\n- ^openshift-*\n- ^kube-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\n</code></pre> <p>Bill has added a new label <code>tenant-network-policy: \"true\"</code> in project section of IntegrationConfig, now MTO will add that label in all tenant projects.</p> <p>Finally, Bill creates a <code>TemplateGroupInstance</code> which will distribute the network policies using the newly added project label and template.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: tenant-network-policy-group\nspec:\ntemplate: tenant-network-policy\nselector:\nmatchLabels:\ntenant-network-policy: \"true\"\nsync: true\n</code></pre> <p>MTO will now deploy the network policies mentioned in <code>Template</code> to all projects matching the label selector mentioned in the TemplateGroupInstance.</p>"},{"location":"reference-guides/custom-roles.html","title":"Changing the default access level for tenant owners","text":"<p>This feature allows the cluster admins to change the default roles assigned to Tenant owner, editor, viewer groups.</p> <p>For example, if Bill as the cluster admin wants to reduce the privileges that tenant owners have, so they cannot create or edit Roles or bind them. As an admin of an OpenShift cluster, Bill can do this by assigning the <code>edit</code> role to all tenant owners. This is easily achieved by modifying the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\ntenantRoles:\ndefault:\nowner:\nclusterRoles:\n- edit\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\n</code></pre> <p>Once all namespaces reconcile, the old <code>admin</code> RoleBindings should get replaced with the <code>edit</code> ones for each tenant owner.</p>"},{"location":"reference-guides/custom-roles.html#giving-specific-permissions-to-some-tenants","title":"Giving specific permissions to some tenants","text":"<p>Bill now wants the owners of the tenants <code>bluesky</code> and <code>alpha</code> to have <code>admin</code> permissions over their namespaces. Custom roles feature will allow Bill to do this, by modifying the IntegrationConfig like this:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\ntenantRoles:\ndefault:\nowner:\nclusterRoles:\n- edit\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\ncustom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\nowner:\nclusterRoles:\n- admin\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- bluesky\nowner:\nclusterRoles:\n- admin\n</code></pre> <p>New Bindings will be created for the Tenant owners of <code>bluesky</code> and <code>alpha</code>, corresponding to the <code>admin</code> Role. Bindings for editors and viewer will be inherited from the <code>default roles</code>. All other Tenant owners will have an <code>edit</code> Role bound to them within their namespaces</p>"},{"location":"reference-guides/deploying-templates.html","title":"Distributing Resources in Namespaces","text":"<p>Multi Tenant Operator has three Custom Resources which can cover this need using the <code>Template</code> CR, depending upon the conditions and preference.</p> <ol> <li>TemplateGroupInstance</li> <li>TemplateInstance</li> <li>Tenant</li> </ol> <p>Stakater Team, however, encourages the use of <code>TemplateGroupInstance</code> to distribute resources in multiple namespaces as it is optimized for better performance.</p>"},{"location":"reference-guides/deploying-templates.html#deploying-template-to-namespaces-via-templategroupinstances","title":"Deploying Template to Namespaces via TemplateGroupInstances","text":"<p>Bill, the cluster admin, wants to deploy a docker pull secret in namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Bill makes a <code>TemplateGroupInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchLabels:\nkind: build\nsync: true\n</code></pre> <p>Afterward, Bill can see that secrets have been successfully created in all label matching namespaces.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   3m\n\nkubectl get secret docker-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   2m\n</code></pre> <p><code>TemplateGroupInstance</code> can also target specific tenants or all tenant namespaces under a single yaml definition.</p>"},{"location":"reference-guides/deploying-templates.html#templategroupinstance-for-multiple-tenants","title":"TemplateGroupInstance for multiple Tenants","text":"<p>It can be done by using the <code>matchExpressions</code> field, dividing the tenant label in key and values.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\n- beta\nsync: true\n</code></pre>"},{"location":"reference-guides/deploying-templates.html#templategroupinstance-for-all-tenants","title":"TemplateGroupInstance for all Tenants","text":"<p>This can also be done by using the <code>matchExpressions</code> field, using just the tenant label key <code>stakater.com/tenant</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: Exists\nsync: true\n</code></pre>"},{"location":"reference-guides/deploying-templates.html#deploying-template-to-namespaces-via-tenant","title":"Deploying Template to Namespaces via Tenant","text":"<p>Bill is a cluster admin who wants to deploy a docker-pull-secret in Anna's tenant namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Bill edits Anna's tenant and populates the <code>namespacetemplate</code> field:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\neditors:\nusers:\n- john@aurora.org\nquota: small\nsandboxConfig:\nenabled: true\ntemplateInstances:\n- spec:\ntemplate: docker-pull-secret\nselector:\nmatchLabels:\nkind: build\n</code></pre> <p>Multi Tenant Operator will deploy <code>TemplateInstances</code> mentioned in <code>templateInstances</code> field, <code>TemplateInstances</code> will only be applied in those <code>namespaces</code> which belong to Anna's <code>tenant</code> and have the matching label of <code>kind: build</code>.</p> <p>So now Anna adds label <code>kind: build</code> to her existing namespace <code>bluesky-anna-aurora-sandbox</code>, and after adding the label she sees that the secret has been created.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME                  STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"reference-guides/deploying-templates.html#deploying-template-to-a-namespace-via-templateinstance","title":"Deploying Template to a Namespace via TemplateInstance","text":"<p>Anna wants to deploy a docker pull secret in her namespace.</p> <p>First Anna asks Bill, the cluster admin, to create a template of the secret for her:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Anna creates a <code>TemplateInstance</code> in her namespace referring to the <code>Template</code> she wants to deploy:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: docker-pull-secret-instance\nnamespace: bluesky-anna-aurora-sandbox\nspec:\ntemplate: docker-pull-secret\nsync: true\n</code></pre> <p>Once this is created, Anna can see that the secret has been successfully applied.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME                  STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"reference-guides/deploying-templates.html#passing-parameters-to-template-via-templateinstance-templategroupinstance-or-tenant","title":"Passing Parameters to Template via TemplateInstance, TemplateGroupInstance or Tenant","text":"<p>Anna wants to deploy a LimitRange resource to certain namespaces.</p> <p>First Anna asks Bill, the cluster admin, to create template with parameters for LimitRange for her:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: namespace-parameterized-restrictions\nparameters:\n# Name of the parameter\n- name: DEFAULT_CPU_LIMIT\n# The default value of the parameter\nvalue: \"1\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"0.5\"\n# If a parameter is required the template instance will need to set it\n# required: true\n# Make sure only values are entered for this parameter\nvalidation: \"^[0-9]*\\\\.?[0-9]+$\"\nresources:\nmanifests:\n- apiVersion: v1\nkind: LimitRange\nmetadata:\nname: namespace-limit-range-${namespace}\nspec:\nlimits:\n- default:\ncpu: \"${{DEFAULT_CPU_LIMIT}}\"\ndefaultRequest:\ncpu: \"${{DEFAULT_CPU_REQUESTS}}\"\ntype: Container\n</code></pre> <p>Afterward, Anna creates a <code>TemplateInstance</code> in her namespace referring to the <code>Template</code> she wants to deploy:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: namespace-parameterized-restrictions-instance\nnamespace: bluesky-anna-aurora-sandbox\nspec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nparameters:\n- name: DEFAULT_CPU_LIMIT\nvalue: \"1.5\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"1\"\n</code></pre> <p>If she wants to distribute the same Template over multiple namespaces, she can use <code>TemplateGroupInstance</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: namespace-parameterized-restrictions-tgi\nspec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\n- beta\nparameters:\n- name: DEFAULT_CPU_LIMIT\nvalue: \"1.5\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"1\"\n</code></pre> <p>Or she can use her tenant to cover only the tenant namespaces.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\neditors:\nusers:\n- john@aurora.org\nquota: small\nsandboxConfig:\nenabled: true\ntemplateInstances:\n- spec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nparameters:\n- name: DEFAULT_CPU_LIMIT\nvalue: \"1.5\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"1\"\nselector:\nmatchLabels:\nkind: build\n</code></pre>"},{"location":"reference-guides/distributing-resources.html","title":"Copying Secrets and Configmaps across Tenant Namespaces via TGI","text":"<p>Bill is a cluster admin who wants to map a <code>docker-pull-secret</code>, present in a <code>build</code> namespace, in tenant namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nresourceMappings:\nsecrets:\n- name: docker-pull-secret\nnamespace: build\n</code></pre> <p>Once the template has been created, Bill makes a <code>TemplateGroupInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchLabels:\nkind: build\nsync: true\n</code></pre> <p>Afterward, Bill can see that secrets has been successfully mapped in all matching namespaces.</p> <pre><code>kubectl get secret docker-pull-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n\nkubectl get secret docker-pull-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"reference-guides/distributing-resources.html#mapping-resources-within-tenant-namespaces-via-ti","title":"Mapping Resources within Tenant Namespaces via TI","text":"<p>Anna is a tenant owner who wants to map a <code>docker-pull-secret</code>, present in <code>bluseky-build</code> namespace, to <code>bluesky-anna-aurora-sandbox</code> namespace.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nresourceMappings:\nsecrets:\n- name: docker-pull-secret\nnamespace: bluesky-build\n</code></pre> <p>Once the template has been created, Anna creates a <code>TemplateInstance</code> in <code>bluesky-anna-aurora-sandbox</code> namespace, referring to the <code>Template</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: docker-secret-instance\nnamespace: bluesky-anna-aurora-sandbox\nspec:\ntemplate: docker-pull-secret\nsync: true\n</code></pre> <p>Afterward, Bill can see that secrets has been successfully mapped in all matching namespaces.</p> <pre><code>kubectl get secret docker-pull-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"reference-guides/distributing-secrets-using-sealed-secret-template.html","title":"Distributing Secrets Using Sealed Secrets Template","text":"<p>Bill is a cluster admin who wants to provide a mechanism for distributing secrets in multiple namespaces. For this, he wants to use Sealed Secrets as the solution by adding them to MTO Template CR</p> <p>First, Bill creates a Template in which Sealed Secret is mentioned:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: tenant-sealed-secret\nresources:\nmanifests:\n- kind: SealedSecret\napiVersion: bitnami.com/v1alpha1\nmetadata:\nname: mysecret\nspec:\nencryptedData:\n.dockerconfigjson: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\ntemplate:\ntype: kubernetes.io/dockerconfigjson\n# this is an example of labels and annotations that will be added to the output secret\nmetadata:\nlabels:\n\"jenkins.io/credentials-type\": usernamePassword\nannotations:\n\"jenkins.io/credentials-description\": credentials from Kubernetes\n</code></pre> <p>Once the template has been created, Bill has to edit the <code>Tenant</code> to add unique label to namespaces in which the secret has to be deployed. For this, he can use the support for common and specific labels across namespaces.</p> <p>Bill has to specify a label on namespaces in which he needs the secret. He can add it to all namespaces inside a tenant or some specific namespaces depending on the use case.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\n\n# use this if you want to add label to some specific namespaces\nspecificMetadata:\n- namespaces:\n- test-namespace\nlabels:\ndistribute-image-pull-secret: true\n\n# use this if you want to add label to all namespaces under your tenant\ncommonMetadata:\nlabels:\ndistribute-image-pull-secret: true\n</code></pre> <p>Bill has added support for a new label <code>distribute-image-pull-secret: true\"</code> for tenant projects/namespaces, now MTO will add that label depending on the used field.</p> <p>Finally, Bill creates a <code>TemplateGroupInstance</code> which will deploy the sealed secrets using the newly created project label and template.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: tenant-sealed-secret\nspec:\ntemplate: tenant-sealed-secret\nselector:\nmatchLabels:\ndistribute-image-pull-secret: true\nsync: true\n</code></pre> <p>MTO will now deploy the sealed secrets mentioned in <code>Template</code> to namespaces which have the mentioned label. The rest of the work to deploy secret from a sealed secret has to be done by Sealed Secrets Controller.</p>"},{"location":"reference-guides/distributing-secrets.html","title":"Distributing Secrets","text":"<p>Bill is a cluster admin who wants to provide a mechanism for distributing secrets in multiple namespaces. For this, he wants to use Sealed Secrets as the solution by adding them to MTO Template CR</p> <p>First, Bill creates a Template in which Sealed Secret is mentioned:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: tenant-sealed-secret\nresources:\nmanifests:\n- kind: SealedSecret\napiVersion: bitnami.com/v1alpha1\nmetadata:\nname: mysecret\nspec:\nencryptedData:\n.dockerconfigjson: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\ntemplate:\ntype: kubernetes.io/dockerconfigjson\n# this is an example of labels and annotations that will be added to the output secret\nmetadata:\nlabels:\n\"jenkins.io/credentials-type\": usernamePassword\nannotations:\n\"jenkins.io/credentials-description\": credentials from Kubernetes\n</code></pre> <p>Once the template has been created, Bill has to edit the <code>Tenant</code> to add unique label to namespaces in which the secret has to be deployed. For this, he can use the support for common and specific labels across namespaces.</p> <p>Bill has to specify a label on namespaces in which he needs the secret. He can add it to all namespaces inside a tenant or some specific namespaces depending on the use case.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\n\n# use this if you want to add label to some specific namespaces\nspecificMetadata:\n- namespaces:\n- test-namespace\nlabels:\ndistribute-image-pull-secret: true\n\n# use this if you want to add label to all namespaces under your tenant\ncommonMetadata:\nlabels:\ndistribute-image-pull-secret: true\n</code></pre> <p>Bill has added support for a new label <code>distribute-image-pull-secret: true\"</code> for tenant projects/namespaces, now MTO will add that label depending on the used field.</p> <p>Finally, Bill creates a <code>TemplateGroupInstance</code> which will deploy the sealed secrets using the newly created project label and template.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: tenant-sealed-secret\nspec:\ntemplate: tenant-sealed-secret\nselector:\nmatchLabels:\ndistribute-image-pull-secret: true\nsync: true\n</code></pre> <p>MTO will now deploy the sealed secrets mentioned in <code>Template</code> to namespaces which have the mentioned label. The rest of the work to deploy secret from a sealed secret has to be done by Sealed Secrets Controller.</p>"},{"location":"reference-guides/extend-default-roles.html","title":"Extending the default access level for tenant members","text":"<p>Bill as the cluster admin wants to extend the default access for tenant members. As an admin of an OpenShift Cluster, Bill can extend the admin, edit, and view ClusterRole using aggregation. Bill will first create a ClusterRole with privileges to resources which Bill wants to extend. Bill will add the aggregation label to the newly created ClusterRole for extending the default ClusterRoles provided by OpenShift.</p> <pre><code>kind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: extend-view-role\nlabels:\nrbac.authorization.k8s.io/aggregate-to-view: 'true'\nrules:\n- verbs:\n- get\n- list\n- watch\napiGroups:\n- user.openshift.io\nresources:\n- groups\n</code></pre> <p>Note: You can learn more about <code>aggregated-cluster-roles</code> here</p>"},{"location":"reference-guides/integrationconfig.html","title":"Configuring Managed Namespaces and ServiceAccounts in IntegrationConfig","text":"<p>Bill is a cluster admin who can use <code>IntegrationConfig</code> to configure how <code>Multi Tenant Operator (MTO)</code> manages the cluster.</p> <p>By default, MTO watches all namespaces and will enforce all the governing policies on them. All namespaces managed by MTO require the <code>stakater.com/tenant</code> label. MTO ignores privileged namespaces that are mentioned in the IntegrationConfig, and does not manage them. Therefore, any tenant label on such namespaces will be ignored.</p> <pre><code>oc create namespace stakater-test\nError from server (Cannot Create namespace stakater-test without label stakater.com/tenant. User: Bill): admission webhook \"vnamespace.kb.io\" denied the request: Cannot CREATE namespace stakater-test without label stakater.com/tenant. User: Bill\n</code></pre> <p>Bill is trying to create a namespace without the <code>stakater.com/tenant</code> label. Creating a namespace without this label is only allowed if the namespace is privileged. Privileged namespaces will be ignored by MTO and do not require the said label. Therefore, Bill will add the required regex in the IntegrationConfig, along with any other namespaces which are privileged and should be ignored by MTO - like <code>default</code>, or namespaces with prefixes like <code>openshift</code>, <code>kube</code>:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nprivilegedNamespaces:\n- ^default$\n- ^openshift*\n- ^kube*\n- ^stakater*\n</code></pre> <p>After mentioning the required regex (<code>^stakater*</code>) under <code>privilegedNamespaces</code>, Bill can create the namespace without interference.</p> <pre><code>oc create namespace stakater-test\nnamespace/stakater-test created\n</code></pre> <p>MTO will also disallow all users which are not tenant owners to perform CRUD operations on namespaces. This will also prevent Service Accounts from performing CRUD operations.</p> <p>If Bill wants MTO to ignore Service Accounts, then he would simply have to add them in the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nprivilegedServiceAccounts:\n- system:serviceaccount:openshift\n- system:serviceaccount:stakater\n- system:serviceaccount:kube\n- system:serviceaccount:redhat\n- system:serviceaccount:hive\n</code></pre> <p>Bill can also use regex patterns to ignore a set of service accounts:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift*\n- ^system:serviceaccount:stakater*\n</code></pre>"},{"location":"reference-guides/integrationconfig.html#configuring-vault-in-integrationconfig","title":"Configuring Vault in IntegrationConfig","text":"<p>Vault is used to secure, store and tightly control access to tokens, passwords, certificates, and encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.</p> <p>If Bill (the cluster admin) has Vault configured in his cluster, then he can take benefit from MTO's integration with Vault.</p> <p>MTO automatically creates Vault secret paths for tenants, where tenant members can securely save their secrets. It also authorizes tenant members to access these secrets via OIDC.</p> <p>Bill would first have to integrate Vault with MTO by adding the details in IntegrationConfig. For more details</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nvault:\nenabled: true\nendpoint:\nsecretReference:\nname: vault-root-token\nnamespace: vault\nurl: &gt;-\nhttps://vault.apps.prod.abcdefghi.kubeapp.cloud/\nsso:\naccessorID: auth_oidc_aa6aa9aa\nclientName: vault\n</code></pre> <p>Bill then creates a tenant for Anna and John:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@acme.org\nviewers:\nusers:\n- john@acme.org\nquota: small\nsandbox: false\n</code></pre> <p>Now Bill goes to <code>Vault</code> and sees that a path for <code>tenant</code> has been made under the name <code>bluesky/kv</code>, confirming that Tenant members with the Owner or Edit roles now have access to the tenant's Vault path.</p> <p>Now if Anna sign's in to the Vault via OIDC, she can see her tenants path and secrets. Whereas if John sign's in to the Vault via OIDC, he can't see his tenants path or secrets as he doesn't have the access required to view them.</p>"},{"location":"reference-guides/integrationconfig.html#configuring-rhsso-red-hat-single-sign-on-in-integrationconfig","title":"Configuring RHSSO (Red Hat Single Sign-On) in IntegrationConfig","text":"<p>Red Hat Single Sign-On RHSSO is based on the Keycloak project and enables you to secure your web applications by providing Web single sign-on (SSO) capabilities based on popular standards such as SAML 2.0, OpenID Connect and OAuth 2.0.</p> <p>If Bill the cluster admin has RHSSO configured in his cluster, then he can take benefit from MTO's integration with RHSSO and Vault.</p> <p>MTO automatically allows tenant members to access Vault via OIDC(RHSSO authentication and authorization) to access secret paths for tenants where tenant members can securely save their secrets.</p> <p>Bill would first have to integrate RHSSO with MTO by adding the details in IntegrationConfig. Visit here for more details.</p> <pre><code>rhsso:\nenabled: true\nrealm: customer\nendpoint:\nsecretReference:\nname: auth-secrets\nnamespace: openshift-auth\nurl: https://iam-keycloak-auth.apps.prod.abcdefghi.kubeapp.cloud/\n</code></pre>"},{"location":"reference-guides/mattermost.html","title":"Creating Mattermost Teams for your tenant","text":""},{"location":"reference-guides/mattermost.html#requirements","title":"Requirements","text":"<p><code>MTO-Mattermost-Integration-Operator</code></p> <p>Please contact stakater to install the Mattermost integration operator before following the below-mentioned steps.</p>"},{"location":"reference-guides/mattermost.html#steps-to-enable-integration","title":"Steps to enable integration","text":"<p>Bill wants some tenants to also have their own Mattermost Teams. To make sure this happens correctly, Bill will first add the <code>stakater.com/mattermost: true</code> label to the tenants. The label will enable the <code>mto-mattermost-integration-operator</code> to create and manage Mattermost Teams based on Tenants.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nlabels:\nstakater.com/mattermost: 'true'\nspec:\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nsandbox: false\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\n</code></pre> <p>Now user can log In to Mattermost to see their Team and relevant channels associated with it.</p> <p></p> <p>The name of the Team is similar to the Tenant name. Notification channels are pre-configured for every team, and can be modified.</p>"},{"location":"reference-guides/secret-distribution.html","title":"Propagate Secrets from Parent to Descendant namespaces","text":"<p>Secrets like <code>registry</code> credentials often need to exist in multiple Namespaces, so that Pods within different namespaces can have access to those credentials in form of secrets.</p> <p>Manually creating secrets within different namespaces could lead to challenges, such as:</p> <ul> <li>Someone will have to create secret either manually or via GitOps each time there is a new descendant namespace that needs the secret</li> <li>If we update the parent secret, they will have to update the secret in all descendant namespaces</li> <li>This could be time-consuming, and a small mistake while creating or updating the secret could lead to unnecessary debugging</li> </ul> <p>With the help of Multi-Tenant Operator's Template feature we can make this secret distribution experience easy.</p> <p>For example, to copy a Secret called <code>registry</code> which exists in the <code>example</code> to new Namespaces whenever they are created, we will first create a Template which will have reference of the registry secret.</p> <p>It will also push updates to the copied Secrets and keep the propagated secrets always sync and updated with parent namespaces.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: registry-secret\nresources:\nresourceMappings:\nsecrets:\n- name: registry\nnamespace: example\n</code></pre> <p>Now using this Template we can propagate registry secret to different namespaces that have some common set of labels.</p> <p>For example, will just add one label <code>kind: registry</code> and all namespaces with this label will get this secret.</p> <p>For propagating it on different namespaces dynamically will have to create another resource called <code>TemplateGroupInstance</code>. <code>TemplateGroupInstance</code> will have <code>Template</code> and <code>matchLabel</code> mapping as shown below:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: registry-secret-group-instance\nspec:\ntemplate: registry-secret\nselector:\nmatchLabels:\nkind: registry\nsync: true\n</code></pre> <p>After reconciliation, you will be able to see those secrets in namespaces having mentioned label.</p> <p>MTO will keep injecting this secret to the new namespaces created with that label.</p> <pre><code>kubectl get secret registry-secret -n example-ns-1\nNAME             STATE    AGE\nregistry-secret    Active   3m\n\nkubectl get secret registry-secret -n example-ns-2\nNAME             STATE    AGE\nregistry-secret    Active   3m\n</code></pre>"},{"location":"tutorials/installation.html","title":"Installation","text":"<p>This document contains instructions on installing, uninstalling and configuring Multi Tenant Operator using OpenShift MarketPlace.</p> <ol> <li> <p>OpenShift OperatorHub UI</p> </li> <li> <p>CLI/GitOps</p> </li> <li> <p>Uninstall</p> </li> </ol>"},{"location":"tutorials/installation.html#requirements","title":"Requirements","text":"<ul> <li>An OpenShift cluster [v4.7 - v4.12]</li> </ul>"},{"location":"tutorials/installation.html#installing-via-operatorhub-ui","title":"Installing via OperatorHub UI","text":"<ul> <li>After opening OpenShift console click on <code>Operators</code>, followed by <code>OperatorHub</code> from the side menu</li> </ul> <ul> <li>Now search for <code>Multi Tenant Operator</code> and then click on <code>Multi Tenant Operator</code> tile</li> </ul> <ul> <li>Click on the <code>install</code> button</li> </ul> <ul> <li>Select <code>Updated channel</code>. Select <code>multi-tenant-operator</code> to install the operator in <code>multi-tenant-operator</code> namespace from <code>Installed Namespace</code> dropdown menu. After configuring <code>Update approval</code> click on the <code>install</code> button.</li> </ul> <p>Note: Use <code>stable</code> channel for seamless upgrades. For <code>Production Environment</code> prefer <code>Manual</code> approval and use <code>Automatic</code> for <code>Development Environment</code></p> <p></p> <ul> <li>Wait for the operator to be installed</li> </ul> <p></p> <ul> <li>Once successfully installed, MTO will be ready to enforce multi-tenancy in your cluster</li> </ul> <p></p> <p>Note: MTO will be installed in <code>multi-tenant-operator</code> namespace.</p>"},{"location":"tutorials/installation.html#configuring-integrationconfig","title":"Configuring IntegrationConfig","text":"<p>IntegrationConfig is required to configure the settings of multi-tenancy for MTO.</p> <ul> <li>We recommend using the following IntegrationConfig as a starting point</li> </ul> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: multi-tenant-operator\nspec:\nopenshift:\nprivilegedNamespaces:\n- default\n- ^openshift-*\n- ^kube-*\n- ^redhat-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:default-*\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\n- ^system:serviceaccount:redhat-*\n</code></pre> <p>For more details and configurations check out IntegrationConfig.</p>"},{"location":"tutorials/installation.html#installing-via-cli-or-gitops","title":"Installing via CLI OR GitOps","text":"<ul> <li>Create namespace <code>multi-tenant-operator</code></li> </ul> <pre><code>oc create namespace multi-tenant-operator\nnamespace/multi-tenant-operator created\n</code></pre> <ul> <li>Create an OperatorGroup YAML for MTO and apply it in <code>multi-tenant-operator</code> namespace.</li> </ul> <pre><code>oc create -f - &lt;&lt; EOF\napiVersion: operators.coreos.com/v1\nkind: OperatorGroup\nmetadata:\n  name: tenant-operator\n  namespace: multi-tenant-operator\nEOF\noperatorgroup.operators.coreos.com/tenant-operator created\n</code></pre> <ul> <li>Create a subscription YAML for MTO and apply it in <code>multi-tenant-operator</code> namespace. To enable console set <code>.spec.config.env[].ENABLE_CONSOLE</code> to <code>true</code>. This will create a route resource, which can be used to access the Multi-Tenant-Operator console.</li> </ul> <pre><code>oc create -f - &lt;&lt; EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: Subscription\nmetadata:\n  name: tenant-operator\n  namespace: multi-tenant-operator\nspec:\n  channel: stable\n  installPlanApproval: Automatic\n  name: tenant-operator\n  source: certified-operators\n  sourceNamespace: openshift-marketplace\n  startingCSV: tenant-operator.v0.9.1\n  config:\n    env:\n      - name: ENABLE_CONSOLE\n        value: 'true'\nEOF\nsubscription.operators.coreos.com/tenant-operator created\n</code></pre> <p>Note: To bring MTO via GitOps, add the above files in GitOps repository.</p> <ul> <li>After creating the <code>subscription</code> custom resource open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu</li> </ul> <p></p> <ul> <li>Wait for the installation to complete</li> </ul> <p></p> <ul> <li>Once the installation is complete click on <code>Workloads</code>, followed by <code>Pods</code> from the side menu and select <code>multi-tenant-operator</code> project</li> </ul> <p></p> <ul> <li>Once pods are up and running, MTO will be ready to enforce multi-tenancy in your cluster</li> </ul> <p></p>"},{"location":"tutorials/installation.html#configuring-integrationconfig_1","title":"Configuring IntegrationConfig","text":"<p>IntegrationConfig is required to configure the settings of multi-tenancy for MTO.</p> <ul> <li>We recommend using the following IntegrationConfig as a starting point:</li> </ul> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: multi-tenant-operator\nspec:\nopenshift:\nprivilegedNamespaces:\n- default\n- ^openshift-*\n- ^kube-*\n- ^redhat-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:default-*\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\n- ^system:serviceaccount:redhat-*\n</code></pre> <p>For more details and configurations check out IntegrationConfig.</p>"},{"location":"tutorials/installation.html#uninstall-via-operatorhub-ui","title":"Uninstall via OperatorHub UI","text":"<p>You can uninstall MTO by following these steps:</p> <ul> <li> <p>Decide on whether you want to retain tenant namespaces and ArgoCD AppProjects or not. If yes, please set <code>spec.onDelete.cleanNamespaces</code> to <code>false</code> for all those tenants whose namespaces you want to retain, and <code>spec.onDelete.cleanAppProject</code> to <code>false</code> for all those tenants whose AppProject you want to retain. For more details check out onDelete</p> </li> <li> <p>After making the required changes open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu</p> </li> </ul> <p></p> <ul> <li>Now click on uninstall and confirm uninstall.</li> </ul> <p></p> <ul> <li> <p>Now the operator has been uninstalled.</p> </li> <li> <p><code>Optional:</code> you can also manually remove MTO's CRDs and its resources from the cluster.</p> </li> </ul>"},{"location":"tutorials/installation.html#notes","title":"Notes","text":"<ul> <li>For more details on how to use MTO please refer use-cases.</li> <li>For more details on how to extend your MTO manager ClusterRole please refer extend-admin-clusterrole.</li> </ul>"},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html","title":"Enabling Multi-Tenancy in ArgoCD","text":""},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html#argocd-integration-in-multi-tenant-operator","title":"ArgoCD integration in Multi Tenant Operator","text":"<p>With Multi Tenant Operator (MTO), cluster admins can configure multi tenancy in their cluster. Now with ArgoCD integration, multi tenancy can be configured in ArgoCD applications and AppProjects.</p> <p>MTO (if configured to) will create AppProjects for each tenant. The AppProject will allow tenants to create ArgoCD Applications that can be synced to namespaces owned by those tenants. Cluster admins will also be able to blacklist certain namespaces resources if they want, and allow certain cluster scoped resources as well (see the <code>NamespaceResourceBlacklist</code> and <code>ClusterResourceWhitelist</code> sections in Integration Config docs and Tenant Custom Resource docs).</p> <p>Note that ArgoCD integration in MTO is completely optional.</p>"},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html#default-argocd-configuration","title":"Default ArgoCD configuration","text":"<p>We have set a default ArgoCD configuration in Multi Tenant Operator that fulfils the following use cases:</p> <ul> <li>Tenants are able to see only their ArgoCD applications in the ArgoCD frontend</li> <li>Tenant 'Owners' and 'Editors' will have full access to their ArgoCD applications</li> <li>Tenants in the 'Viewers' group will have read-only access to their ArgoCD applications</li> <li>Tenants can sync all namespace-scoped resources, except those that are blacklisted in the spec</li> <li>Tenants can only sync cluster-scoped resources that are whitelisted in the spec</li> <li>Tenant 'Owners' can configure their own GitOps source repos at a tenant level</li> <li>Cluster admins can prevent specific resources from syncing via ArgoCD</li> <li>Cluster admins have full access to all ArgoCD applications and AppProjects</li> <li>Since ArgoCD integration is on a per-tenant level, namespace-scoped applications are only synced to Tenant's namespaces</li> </ul> <p>Detailed use cases showing how to create AppProjects are mentioned in use cases for ArgoCD.</p>"},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html#creating-argocd-appprojects-for-your-tenant","title":"Creating ArgoCD AppProjects for your tenant","text":"<p>Bill wants each tenant to also have their own ArgoCD AppProjects. To make sure this happens correctly, Bill will first specify the ArgoCD namespace in the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\n...\nargocd:\nnamespace: openshift-operators\n...\n</code></pre> <p>Afterward, Bill must specify the source GitOps repos for the tenant inside the tenant CR like so:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nspec:\nargocd:\nsourceRepos:\n# specify source repos here\n- \"https://github.com/stakater/GitOps-config\"\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nsandbox: false\nnamespaces:\nwithTenantPrefix:\n- build\n- stage\n- dev\n</code></pre> <p>Now Bill can see an AppProject will be created for the tenant</p> <pre><code>oc get AppProject -A\nNAMESPACE             NAME           AGE\nopenshift-operators   sigma        5d15h\n</code></pre> <p>The following AppProject is created:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: sigma\nnamespace: openshift-operators\nspec:\ndestinations:\n- namespace: sigma-build\nserver: \"https://kubernetes.default.svc\"\n- namespace: sigma-dev\nserver: \"https://kubernetes.default.svc\"\n- namespace: sigma-stage\nserver: \"https://kubernetes.default.svc\"\nroles:\n- description: &gt;-\nRole that gives full access to all resources inside the tenant's\nnamespace to the tenant owner groups\ngroups:\n- saap-cluster-admins\n- stakater-team\n- sigma-owner-group\nname: sigma-owner\npolicies:\n- \"p, proj:sigma:sigma-owner, *, *, sigma/*, allow\"\n- description: &gt;-\nRole that gives edit access to all resources inside the tenant's\nnamespace to the tenant owner group\ngroups:\n- saap-cluster-admins\n- stakater-team\n- sigma-edit-group\nname: sigma-edit\npolicies:\n- \"p, proj:sigma:sigma-edit, *, *, sigma/*, allow\"\n- description: &gt;-\nRole that gives view access to all resources inside the tenant's\nnamespace to the tenant owner group\ngroups:\n- saap-cluster-admins\n- stakater-team\n- sigma-view-group\nname: sigma-view\npolicies:\n- \"p, proj:sigma:sigma-view, *, get, sigma/*, allow\"\nsourceRepos:\n- \"https://github.com/stakater/gitops-config\"\n</code></pre> <p>Users belonging to the Sigma group will now only see applications created by them in the ArgoCD frontend now:</p> <p></p>"},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html#prevent-argocd-from-syncing-certain-namespaced-resources","title":"Prevent ArgoCD from syncing certain namespaced resources","text":"<p>Bill wants tenants to not be able to sync <code>ResourceQuota</code> and <code>LimitRange</code> resources to their namespaces. To do this correctly, Bill will specify these resources to blacklist in the ArgoCD portion of the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\n...\nargocd:\nnamespace: openshift-operators\nnamespaceResourceBlacklist:\n- group: \"\"\nkind: ResourceQuota\n- group: \"\"\nkind: LimitRange\n...\n</code></pre> <p>Now, if these resources are added to any tenant's project directory in GitOps, ArgoCD will not sync them to the cluster. The AppProject will also have the blacklisted resources added to it:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: sigma\nnamespace: openshift-operators\nspec:\n...\nnamespaceResourceBlacklist:\n- group: ''\nkind: ResourceQuota\n- group: ''\nkind: LimitRange\n...\n</code></pre>"},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html#allow-argocd-to-sync-certain-cluster-wide-resources","title":"Allow ArgoCD to sync certain cluster-wide resources","text":"<p>Bill now wants tenants to be able to sync the <code>Environment</code> cluster scoped resource to the cluster. To do this correctly, Bill will specify the resource to whitelist in the ArgoCD portion of the Integration Config's Spec:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\n...\nargocd:\nnamespace: openshift-operators\nclusterResourceWhitelist:\n- group: \"\"\nkind: Environment\n...\n</code></pre> <p>Now, if the resource is added to any tenant's project directory in GitOps, ArgoCD will sync them to the cluster. The AppProject will also have the whitelisted resources added to it:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: sigma\nnamespace: openshift-operators\nspec:\n...\nclusterResourceWhitelist:\n- group: \"\"\nkind: Environment\n...\n</code></pre>"},{"location":"tutorials/argocd/enabling-multi-tenancy-argocd.html#override-namespaceresourceblacklist-andor-clusterresourcewhitelist-per-tenant","title":"Override NamespaceResourceBlacklist and/or ClusterResourceWhitelist per Tenant","text":"<p>Bill now wants a specific tenant to override the <code>namespaceResourceBlacklist</code> and/or <code>clusterResourceWhitelist</code> set via Integration Config. Bill will specify these in <code>argoCD.appProjects</code> section of Tenant spec.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: blue-sky\nspec:\nargocd:\nsourceRepos:\n# specify source repos here\n- \"https://github.com/stakater/GitOps-config\"\nappProject:\nclusterResourceWhitelist:\n- group: admissionregistration.k8s.io\nkind: validatingwebhookconfigurations\nnamespaceResourceBlacklist:\n- group: \"\"\nkind: ConfigMap\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nsandbox: false\nnamespaces:\nwithTenantPrefix:\n- build\n- stage\n</code></pre>"},{"location":"tutorials/template/template-group-instance.html","title":"More about TemplateGroupInstance","text":""},{"location":"tutorials/template/template-instance.html","title":"More about TemplateInstances","text":""},{"location":"tutorials/template/template.html","title":"Understanding and Utilizing Template","text":""},{"location":"tutorials/template/template.html#creating-templates","title":"Creating Templates","text":"<p>Anna wants to create a Template that she can use to initialize or share common resources across namespaces (e.g. PullSecrets).</p> <p>Anna can either create a template using <code>manifests</code> field, covering Kubernetes or custom resources.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Or by using <code>Helm Charts</code></p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: redis\nresources:\nhelm:\nreleaseName: redis\nchart:\nrepository:\nname: redis\nrepoUrl: https://charts.bitnami.com/bitnami\nvalues: |\nredisPort: 6379\n</code></pre> <p>She can also use <code>resourceMapping</code> field to copy over secrets and configmaps from one namespace to others.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: resource-mapping\nresources:\nresourceMappings:\nsecrets:\n- name: docker-secret\nnamespace: bluesky-build\nconfigMaps:\n- name: tronador-configMap\nnamespace: stakater-tronador\n</code></pre> <p>Note: Resource mapping can be used via TGI to map resources within tenant namespaces or to some other tenant's namespace. If used with TI, the resources will only be mapped if namespaces belong to same tenant.</p>"},{"location":"tutorials/template/template.html#using-templates-with-default-parameters","title":"Using Templates with Default Parameters","text":"<pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: namespace-parameterized-restrictions\nparameters:\n# Name of the parameter\n- name: DEFAULT_CPU_LIMIT\n# The default value of the parameter\nvalue: \"1\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"0.5\"\n# If a parameter is required the template instance will need to set it\n# required: true\n# Make sure only values are entered for this parameter\nvalidation: \"^[0-9]*\\\\.?[0-9]+$\"\nresources:\nmanifests:\n- apiVersion: v1\nkind: LimitRange\nmetadata:\nname: namespace-limit-range-${namespace}\nspec:\nlimits:\n- default:\ncpu: \"${{DEFAULT_CPU_LIMIT}}\"\ndefaultRequest:\ncpu: \"${{DEFAULT_CPU_REQUESTS}}\"\ntype: Container\n</code></pre> <p>Parameters can be used with both <code>manifests</code> and <code>helm charts</code></p>"},{"location":"tutorials/tenant/assign-quota-tenant.html","title":"Assign Quota to a Tenant","text":""},{"location":"tutorials/tenant/assigning-metadata.html","title":"Assigning Common/Specific Metadata","text":""},{"location":"tutorials/tenant/assigning-metadata.html#distributing-common-labels-and-annotations-to-tenant-namespaces-via-tenant-custom-resource","title":"Distributing common labels and annotations to tenant namespaces via Tenant Custom Resource","text":"<p>Bill now wants to add labels/annotations to all the namespaces for a tenant. To create those labels/annotations Bill will just add them into <code>commonMetadata.labels</code>/<code>commonMetadata.annotations</code> field in the tenant CR.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\ncommonMetadata:\nlabels:\napp.kubernetes.io/managed-by: tenant-operator\napp.kubernetes.io/part-of: tenant-alpha\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/infra=\nEOF\n</code></pre> <p>With the above configuration all tenant namespaces will now contain the mentioned labels and annotations.</p>"},{"location":"tutorials/tenant/assigning-metadata.html#distributing-specific-labels-and-annotations-to-tenant-namespaces-via-tenant-custom-resource","title":"Distributing specific labels and annotations to tenant namespaces via Tenant Custom Resource","text":"<p>Bill now wants to add labels/annotations to specific namespaces for a tenant. To create those labels/annotations Bill will just add them into <code>specificMetadata.labels</code>/<code>specificMetadata.annotations</code> and specific namespaces in <code>specificMetadata.namespaces</code> field in the tenant CR.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandboxConfig:\nenabled: true\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\nspecificMetadata:\n- namespaces:\n- bluesky-anna-aurora-sandbox\nlabels:\napp.kubernetes.io/is-sandbox: true\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\nEOF\n</code></pre> <p>With the above configuration all tenant namespaces will now contain the mentioned labels and annotations.</p>"},{"location":"tutorials/tenant/create-sandbox.html","title":"Create Sandbox Namespaces for Tenant Users","text":""},{"location":"tutorials/tenant/create-sandbox.html#assigning-users-sandbox-namespace","title":"Assigning Users Sandbox Namespace","text":"<p>Bill assigned the ownership of <code>bluesky</code> to <code>Anna</code> and <code>Anthony</code>. Now if the users want sandboxes to be made for them, they'll have to ask <code>Bill</code> to enable <code>sandbox</code> functionality.</p> <p>To enable that, Bill will just set <code>enabled: true</code> within the <code>sandboxConfig</code> field</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandboxConfig:\nenabled: true\nEOF\n</code></pre> <p>With the above configuration <code>Anna</code> and <code>Anthony</code> will now have new sandboxes created</p> <pre><code>kubectl get namespaces\nNAME                             STATUS   AGE\nbluesky-anna-aurora-sandbox      Active   5d5h\nbluesky-anthony-aurora-sandbox   Active   5d5h\nbluesky-john-aurora-sandbox      Active   5d5h\n</code></pre> <p>If Bill wants to make sure that only the sandbox owner can view his sandbox namespace, he can achieve this by setting <code>private: true</code> within the <code>sandboxConfig</code> filed.</p>"},{"location":"tutorials/tenant/create-sandbox.html#create-private-sandboxes","title":"Create Private Sandboxes","text":"<p>Bill assigned the ownership of <code>bluesky</code> to <code>Anna</code> and <code>Anthony</code>. Now if the users want sandboxes to be made for them, they'll have to ask <code>Bill</code> to enable <code>sandbox</code> functionality. The Users also want to make sure that the sandboxes that are created for them are also only visible to the user they belong to. To enable that, Bill will just set <code>enabled: true</code> and <code>private: true</code> within the <code>sandboxConfig</code> field</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandboxConfig:\nenabled: true\nprivate: true\nEOF\n</code></pre> <p>With the above configuration <code>Anna</code> and <code>Anthony</code> will now have new sandboxes created</p> <pre><code>kubectl get namespaces\nNAME                             STATUS   AGE\nbluesky-anna-aurora-sandbox      Active   5d5h\nbluesky-anthony-aurora-sandbox   Active   5d5h\nbluesky-john-aurora-sandbox      Active   5d5h\n</code></pre> <p>However, from the perspective of <code>Anna</code>, only their sandbox will be visible</p> <pre><code>kubectl get namespaces\nNAME                             STATUS   AGE\nbluesky-anna-aurora-sandbox      Active   5d5h\n</code></pre>"},{"location":"tutorials/tenant/create-tenant.html","title":"Creating a Tenant","text":"<p>Bill is a cluster admin who receives a new request from Aurora Solutions CTO asking for a new tenant for Anna's team.</p> <p>Bill creates a new tenant called <code>bluesky</code> in the cluster:</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandbox: false\nEOF\n</code></pre> <p>Bill checks if the new tenant is created:</p> <pre><code>kubectl get tenants.tenantoperator.stakater.com bluesky\nNAME       STATE    AGE\nbluesky    Active   3m\n</code></pre> <p>Anna can now log in to the cluster and check if she can create namespaces</p> <pre><code>kubectl auth can-i create namespaces\nyes\n</code></pre> <p>However, cluster resources are not accessible to Anna</p> <pre><code>kubectl auth can-i get namespaces\nno\n\nkubectl auth can-i get persistentvolumes\nno\n</code></pre> <p>Including the <code>Tenant</code> resource</p> <pre><code>kubectl auth can-i get tenants.tenantoperator.stakater.com\nno\n</code></pre>"},{"location":"tutorials/tenant/create-tenant.html#assign-multiple-users-as-tenant-owner","title":"Assign multiple users as tenant owner","text":"<p>In the example above, Bill assigned the ownership of <code>bluesky</code> to <code>Anna</code>. If another user, e.g. <code>Anthony</code> needs to administer <code>bluesky</code>, than Bill can assign the ownership of tenant to that user as well:</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandbox: false\nEOF\n</code></pre> <p>With the configuration above, Anthony can log in to the cluster and execute</p> <pre><code>kubectl auth can-i create namespaces\nyes\n</code></pre>"},{"location":"tutorials/tenant/creating-namespaces.html","title":"Creating Namespaces","text":""},{"location":"tutorials/tenant/creating-namespaces.html#creating-namespaces-via-tenant-custom-resource","title":"Creating Namespaces via Tenant Custom Resource","text":"<p>Bill now wants to create namespaces for <code>dev</code>, <code>build</code> and <code>production</code> environments for the tenant members. To create those namespaces Bill will just add those names within the <code>namespaces</code> field in the tenant CR. If Bill wants to append the tenant name as a prefix in namespace name, then he can use <code>namespaces.withTenantPrefix</code> field. Else he can use <code>namespaces.withoutTenantPrefix</code> for namespaces for which he does not need tenant name as a prefix.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\nwithoutTenantPrefix:\n- prod\nEOF\n</code></pre> <p>With the above configuration tenant members will now see new namespaces have been created.</p> <pre><code>kubectl get namespaces\nNAME             STATUS   AGE\nbluesky-dev      Active   5d5h\nbluesky-build    Active   5d5h\nprod             Active   5d5h\n</code></pre> <p>Anna as the tenant owner can create new namespaces for her tenant.</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: bluesky-production\nlabels:\nstakater.com/tenant: bluesky\n</code></pre> <p>\u26a0\ufe0f Anna is required to add the tenant label <code>stakater.com/tenant: bluesky</code> which contains the name of her tenant <code>bluesky</code>, while creating the namespace. If this label is not added or if Anna does not belong to the <code>bluesky</code> tenant, then Multi Tenant Operator will not allow the creation of that namespace.</p> <p>When Anna creates the namespace, MTO assigns Anna and other tenant members the roles based on their user types, such as a tenant owner getting the OpenShift <code>admin</code> role for that namespace.</p> <p>As a tenant owner, Anna is able to create namespaces.</p> <p>If you have enabled ArgoCD Multitenancy, our preferred solution is to create tenant namespaces by using Tenant spec to avoid syncing issues in ArgoCD console during namespace creation.</p>"},{"location":"tutorials/tenant/creating-namespaces.html#add-existing-namespaces-to-tenant-via-gitops","title":"Add Existing Namespaces to Tenant via GitOps","text":"<p>Using GitOps as your preferred development workflow, you can add existing namespaces for your tenants by including the tenant label.</p> <p>To add an existing namespace to your tenant via GitOps:</p> <ol> <li>First, migrate your namespace resource to your \u201cwatched\u201d git repository</li> <li>Edit your namespace <code>yaml</code> to include the tenant label</li> <li>Tenant label follows the naming convention <code>stakater.com/tenant: &lt;TENANT_NAME&gt;</code></li> <li>Sync your GitOps repository with your cluster and allow changes to be propagated</li> <li>Verify that your Tenant users now have access to the namespace</li> </ol> <p>For example, If Anna, a tenant owner, wants to add the namespace <code>bluesky-dev</code> to her tenant via GitOps, after migrating her namespace manifest to a \u201cwatched repository\u201d</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: bluesky-dev\n</code></pre> <p>She can then add the tenant label</p> <pre><code> ...\nlabels:\nstakater.com/tenant: bluesky\n</code></pre> <p>Now all the users of the <code>Bluesky</code> tenant now have access to the existing namespace.</p> <p>Additionally, to remove namespaces from a tenant, simply remove the tenant label from the namespace resource and sync your changes to your cluster.</p>"},{"location":"tutorials/tenant/creating-namespaces.html#remove-namespaces-from-your-cluster-via-gitops","title":"Remove Namespaces from your Cluster via GitOps","text":"<p>GitOps is a quick and efficient way to automate the management of your K8s resources.</p> <p>To remove namespaces from your cluster via GitOps;</p> <ul> <li>Remove the <code>yaml</code> file containing your namespace configurations from your \u201cwatched\u201d git repository.</li> <li>ArgoCD automatically sets the <code>[app.kubernetes.io/instance](http://app.kubernetes.io/instance)</code> label on resources it manages. It uses this label it to select resources which inform the basis of an app. To remove a namespace from a managed ArgoCD app, remove the ArgoCD label <code>app.kubernetes.io/instance</code> from the namespace manifest.</li> <li>You can edit your namespace manifest through the OpenShift Web Console or with the OpenShift command line tool.</li> <li>Now that you have removed your namespace manifest from your watched git repository, and from your managed ArgoCD apps, sync your git repository and allow your changes be propagated.</li> <li>Verify that your namespace has been deleted.</li> </ul>"},{"location":"tutorials/tenant/custom-rbac.html","title":"Applying Custom RBAC to a Tenant","text":""},{"location":"tutorials/tenant/deleting-tenant.html","title":"Deleting a Tenant","text":""},{"location":"tutorials/tenant/deleting-tenant.html#retaining-tenant-namespaces-and-appproject-when-a-tenant-is-being-deleted","title":"Retaining tenant namespaces and AppProject when a tenant is being deleted","text":"<p>Bill now wants to delete tenant <code>bluesky</code> and wants to retain all namespaces and AppProject of the tenant. To retain the namespaces Bill will set <code>spec.onDelete.cleanNamespaces</code>, and <code>spec.onDelete.cleanAppProjects</code> to <code>false</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\nquota: small\nsandboxConfig:\nenabled: true\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\nonDelete:\ncleanNamespaces: false\ncleanAppProject: false\n</code></pre> <p>With the above configuration all tenant namespaces and AppProject will not be deleted when tenant <code>bluesky</code> is deleted. By default, the value of <code>spec.onDelete.cleanNamespaces</code> is also <code>false</code> and <code>spec.onDelete.cleanAppProject</code> is <code>true</code></p>"},{"location":"tutorials/tenant/tenant-hibernation.html","title":"Hibernating a Tenant","text":""},{"location":"tutorials/tenant/tenant-hibernation.html#hibernating-namespaces","title":"Hibernating Namespaces","text":"<p>You can manage workloads in your cluster with MTO by implementing a hibernation schedule for your tenants. Hibernation downsizes the running Deployments and StatefulSets in a tenant\u2019s namespace according to a defined cron schedule. You can set a hibernation schedule for your tenants by adding the \u2018spec.hibernation\u2019 field to the tenant's respective Custom Resource.</p> <pre><code>hibernation:\nsleepSchedule: 23 * * * *\nwakeSchedule: 26 * * * *\n</code></pre> <p><code>spec.hibernation.sleepSchedule</code> accepts a cron expression indicating the time to put the workloads in your tenant\u2019s namespaces to sleep.</p> <p><code>spec.hibernation.wakeSchedule</code> accepts a cron expression indicating the time to wake the workloads in your tenant\u2019s namespaces up.</p> <p>Note</p> <p>Both sleep and wake schedules must be specified for your Hibernation schedule to be valid.</p> <p>Additionally, adding the <code>hibernation.stakater.com/exclude: 'true'</code> annotation to a namespace excludes it from hibernating.</p> <p>Note</p> <p>This is only true for hibernation applied via the Tenant Custom Resource, and does not apply for hibernation done by manually creating a ResourceSupervisor (details about that below).</p> <p>Note</p> <p>This will not wake up an already sleeping namespace before the wake schedule.</p>"},{"location":"tutorials/tenant/tenant-hibernation.html#resource-supervisor","title":"Resource Supervisor","text":"<p>Adding a Hibernation Schedule to a Tenant creates an accompanying ResourceSupervisor Custom Resource. The Resource Supervisor stores the Hibernation schedules and manages the current and previous states of all the applications, whether they are sleeping or awake.</p> <p>When the sleep timer is activated, the Resource Supervisor controller stores the details of your applications (including the number of replicas, configurations, etc.) in the applications' namespaces and then puts your applications to sleep. When the wake timer is activated, the controller wakes up the applications using their stored details.</p> <p>Enabling ArgoCD support for Tenants will also hibernate applications in the tenants' <code>appProjects</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: sigma\nspec:\nargocd:\nappProjects:\n- sigma\nnamespace: openshift-gitops\nhibernation:\nsleepSchedule: 42 * * * *\nwakeSchedule: 45 * * * *\nnamespaces:\n- tenant-ns1\n- tenant-ns2\n</code></pre> <p>Currently, Hibernation is available only for StatefulSets and Deployments.</p>"},{"location":"tutorials/tenant/tenant-hibernation.html#manual-creation-of-resourcesupervisor","title":"Manual creation of ResourceSupervisor","text":"<p>Hibernation can also be applied by creating a ResourceSupervisor resource manually. The ResourceSupervisor definition will contain the hibernation cron schedule, the names of the namespaces to be hibernated, and the names of the ArgoCD AppProjects whose ArgoCD Applications have to be hibernated (as per the given schedule).</p> <p>This method can be used to hibernate:</p> <ul> <li>Some specific namespaces and AppProjects in a tenant</li> <li>A set of namespaces and AppProjects belonging to different tenants</li> <li>Namespaces and AppProjects belonging to a tenant that the cluster admin is not a member of</li> <li>Non-tenant namespaces and ArgoCD AppProjects</li> </ul> <p>As an example, the following ResourceSupervisor could be created manually, to apply hibernation explicitly to the 'ns1' and 'ns2' namespaces, and to the 'sample-app-project' AppProject.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: hibernator\nspec:\nargocd:\nappProjects:\n- sample-app-project\nnamespace: openshift-gitops\nhibernation:\nsleepSchedule: 42 * * * *\nwakeSchedule: 45 * * * *\nnamespaces:\n- ns1\n- ns2\n</code></pre>"},{"location":"tutorials/tenant/tenant-hibernation.html#freeing-up-unused-resources-with-hibernation","title":"Freeing up unused resources with hibernation","text":""},{"location":"tutorials/tenant/tenant-hibernation.html#hibernating-a-tenant_1","title":"Hibernating a tenant","text":"<p>Bill is a cluster administrator who wants to free up unused cluster resources at nighttime, in an effort to reduce costs (when the cluster isn't being used).</p> <p>First, Bill creates a tenant with the <code>hibernation</code> schedules mentioned in the spec, or adds the hibernation field to an existing tenant:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nspec:\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nnamespaces:\nwithoutTenantPrefix:\n- build\n- stage\n- dev\n</code></pre> <p>The schedules above will put all the <code>Deployments</code> and <code>StatefulSets</code> within the tenant's namespaces to sleep, by reducing their pod count to 0 at 8 PM every weekday. At 8 AM on weekdays, the namespaces will then wake up by restoring their applications' previous pod counts.</p> <p>Bill can verify this behaviour by checking the newly created ResourceSupervisor resource at run time:</p> <pre><code>oc get ResourceSupervisor -A\nNAME           AGE\nsigma          5m\n</code></pre> <p>The ResourceSupervisor will look like this at 'running' time (as per the schedule):</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: example\nspec:\nargocd:\nappProjects: []\nnamespace: ''\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- build\n- stage\n- dev\nstatus:\ncurrentStatus: running\nnextReconcileTime: '2022-10-12T20:00:00Z'\n</code></pre> <p>The ResourceSupervisor will look like this at 'sleeping' time (as per the schedule):</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: example\nspec:\nargocd:\nappProjects: []\nnamespace: ''\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- build\n- stage\n- dev\nstatus:\ncurrentStatus: sleeping\nnextReconcileTime: '2022-10-13T08:00:00Z'\nsleepingApplications:\n- Namespace: build\nkind: Deployment\nname: example\nreplicas: 3\n- Namespace: stage\nkind: Deployment\nname: example\nreplicas: 3\n</code></pre> <p>Bill wants to prevent the <code>build</code> namespace from going to sleep, so he can add the <code>hibernation.stakater.com/exclude: 'true'</code> annotation to it. The ResourceSupervisor will now look like this after reconciling:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: example\nspec:\nargocd:\nappProjects: []\nnamespace: ''\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- stage\n- dev\nstatus:\ncurrentStatus: sleeping\nnextReconcileTime: '2022-10-13T08:00:00Z'\nsleepingApplications:\n- Namespace: stage\nkind: Deployment\nname: example\nreplicas: 3\n</code></pre>"},{"location":"tutorials/tenant/tenant-hibernation.html#hibernating-namespaces-andor-argocd-applications-with-resourcesupervisor","title":"Hibernating namespaces and/or ArgoCD Applications with ResourceSupervisor","text":"<p>Bill, the cluster administrator, wants to hibernate a collection of namespaces and AppProjects belonging to multiple different tenants. He can do so by creating a ResourceSupervisor manually, specifying the hibernation schedule in its spec, the namespaces and ArgoCD Applications that need to be hibernated as per the mentioned schedule. Bill can also use the same method to hibernate some namespaces and ArgoCD Applications that do not belong to any tenant on his cluster.</p> <p>The example given below will hibernate the ArgoCD Applications in the 'test-app-project' AppProject; and it will also hibernate the 'ns2' and 'ns4' namespaces.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: test-resource-supervisor\nspec:\nargocd:\nappProjects:\n- test-app-project\nnamespace: argocd-ns\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- ns2\n- ns4\nstatus:\ncurrentStatus: sleeping\nnextReconcileTime: '2022-10-13T08:00:00Z'\nsleepingApplications:\n- Namespace: ns2\nkind: Deployment\nname: test-deployment\nreplicas: 3\n</code></pre>"},{"location":"tutorials/vault/enabling-multi-tenancy-vault.html","title":"Enabling Multi-Tenancy in Vault","text":""},{"location":"tutorials/vault/enabling-multi-tenancy-vault.html#vault-multitenancy","title":"Vault Multitenancy","text":"<p>HashiCorp Vault is an identity-based secret and encryption management system. Vault validates and authorizes a system's clients (users, machines, apps) before providing them access to secrets or stored sensitive data.</p>"},{"location":"tutorials/vault/enabling-multi-tenancy-vault.html#vault-integration-in-multi-tenant-operator","title":"Vault integration in Multi Tenant Operator","text":""},{"location":"tutorials/vault/enabling-multi-tenancy-vault.html#service-account-auth-in-vault","title":"Service Account Auth in Vault","text":"<p>MTO enables the Kubernetes auth method which can be used to authenticate with Vault using a Kubernetes Service Account Token. When enabled, for every tenant namespace, MTO automatically creates policies and roles that allow the service accounts present in those namespaces to read secrets at tenant's path in Vault. The name of the role is the same as namespace name.</p> <p>These service accounts are required to have <code>stakater.com/vault-access: true</code> label, so they can be authenticated with Vault via MTO.</p> <p>The Diagram shows how MTO enables ServiceAccounts to read secrets from Vault.</p> <p></p>"},{"location":"tutorials/vault/enabling-multi-tenancy-vault.html#user-oidc-auth-in-vault","title":"User OIDC Auth in Vault","text":"<p>This requires a running <code>RHSSO(RedHat Single Sign On)</code> instance integrated with Vault over OIDC login method.</p> <p>MTO integration with Vault and RHSSO provides a way for users to log in to Vault where they only have access to relevant tenant paths.</p> <p>Once both integrations are set-up with IntegrationConfig CR, MTO links tenant users to specific client roles named after their tenant under Vault client in RHSSO.</p> <p>After that, MTO creates specific policies in Vault for its tenant users.</p> <p>Mapping of tenant roles to Vault is shown below</p> Tenant Role Vault Path Vault Capabilities Owner, Editor (tenantName)/* Create, Read, Update, Delete, List Owner, Editor sys/mounts/(tenantName)/* Create, Read, Update, Delete, List Owner, Editor managed-addons/* Read, List Viewer (tenantName)/* Read <p>A simple user login workflow is shown in the diagram below.</p> <p></p>"},{"location":"usecases/admin-clusterrole.html","title":"Extending Admin ClusterRole","text":"<p>Bill as the cluster admin want to add additional rules for admin ClusterRole.</p> <p>Bill can extend the <code>admin</code> role for MTO using the aggregation label for admin ClusterRole. Bill will create a new ClusterRole with all the permissions he needs to extend for MTO and add the aggregation label on the newly created ClusterRole.</p> <pre><code>kind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: extend-admin-role\nlabels:\nrbac.authorization.k8s.io/aggregate-to-admin: 'true'\nrules:\n- verbs:\n- create\n- update\n- patch\n- delete\napiGroups:\n- user.openshift.io\nresources:\n- groups\n</code></pre> <p>Note: You can learn more about <code>aggregated-cluster-roles</code> here</p>"},{"location":"usecases/admin-clusterrole.html#whats-next","title":"What\u2019s next","text":"<p>See how Bill can hibernate unused namespaces at night</p>"},{"location":"usecases/argocd.html","title":"ArgoCD","text":""},{"location":"usecases/argocd.html#creating-argocd-appprojects-for-your-tenant","title":"Creating ArgoCD AppProjects for your tenant","text":"<p>Bill wants each tenant to also have their own ArgoCD AppProjects. To make sure this happens correctly, Bill will first specify the ArgoCD namespace in the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\n...\nargocd:\nnamespace: openshift-operators\n...\n</code></pre> <p>Afterwards, Bill must specify the source GitOps repos for the tenant inside the tenant CR like so:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nspec:\nargocd:\nsourceRepos:\n# specify source repos here\n- \"https://github.com/stakater/GitOps-config\"\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nsandbox: false\nnamespaces:\nwithTenantPrefix:\n- build\n- stage\n- dev\n</code></pre> <p>Now Bill can see an AppProject will be created for the tenant</p> <pre><code>oc get AppProject -A\nNAMESPACE             NAME           AGE\nopenshift-operators   sigma        5d15h\n</code></pre> <p>The following AppProject is created:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: sigma\nnamespace: openshift-operators\nspec:\ndestinations:\n- namespace: sigma-build\nserver: \"https://kubernetes.default.svc\"\n- namespace: sigma-dev\nserver: \"https://kubernetes.default.svc\"\n- namespace: sigma-stage\nserver: \"https://kubernetes.default.svc\"\nroles:\n- description: &gt;-\nRole that gives full access to all resources inside the tenant's\nnamespace to the tenant owner group\ngroups:\n- saap-cluster-admins\n- stakater-team\n- sigma-owner-group\nname: sigma-owner\npolicies:\n- \"p, proj:sigma:sigma-owner, *, *, sigma/*, allow\"\n- description: &gt;-\nRole that gives edit access to all resources inside the tenant's\nnamespace to the tenant owner group\ngroups:\n- saap-cluster-admins\n- stakater-team\n- sigma-edit-group\nname: sigma-edit\npolicies:\n- \"p, proj:sigma:sigma-edit, *, *, sigma/*, allow\"\n- description: &gt;-\nRole that gives view access to all resources inside the tenant's\nnamespace to the tenant owner group\ngroups:\n- saap-cluster-admins\n- stakater-team\n- sigma-view-group\nname: sigma-view\npolicies:\n- \"p, proj:sigma:sigma-view, *, get, sigma/*, allow\"\nsourceRepos:\n- \"https://github.com/stakater/gitops-config\"\n</code></pre> <p>Users belonging to the Sigma group will now only see applications created by them in the ArgoCD frontend now:</p> <p></p>"},{"location":"usecases/argocd.html#prevent-argocd-from-syncing-certain-namespaced-resources","title":"Prevent ArgoCD from syncing certain namespaced resources","text":"<p>Bill wants tenants to not be able to sync <code>ResourceQuota</code> and <code>LimitRange</code> resources to their namespaces. To do this correctly, Bill will specify these resources to blacklist in the ArgoCD portion of the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\n...\nargocd:\nnamespace: openshift-operators\nnamespaceResourceBlacklist:\n- group: \"\"\nkind: ResourceQuota\n- group: \"\"\nkind: LimitRange\n...\n</code></pre> <p>Now, if these resources are added to any tenant's project directory in GitOps, ArgoCD will not sync them to the cluster. The AppProject will also have the blacklisted resources added to it:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: sigma\nnamespace: openshift-operators\nspec:\n...\nnamespaceResourceBlacklist:\n- group: ''\nkind: ResourceQuota\n- group: ''\nkind: LimitRange\n...\n</code></pre>"},{"location":"usecases/argocd.html#allow-argocd-to-sync-certain-cluster-wide-resources","title":"Allow ArgoCD to sync certain cluster-wide resources","text":"<p>Bill now wants tenants to be able to sync the <code>Environment</code> cluster scoped resource to the cluster. To do this correctly, Bill will specify the resource to whitelist in the ArgoCD portion of the Integration Config's Spec:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\n...\nargocd:\nnamespace: openshift-operators\nclusterResourceWhitelist:\n- group: \"\"\nkind: Environment\n...\n</code></pre> <p>Now, if the resource is added to any tenant's project directory in GitOps, ArgoCD will sync them to the cluster. The AppProject will also have the whitelisted resources added to it:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: sigma\nnamespace: openshift-operators\nspec:\n...\nclusterResourceWhitelist:\n- group: \"\"\nkind: Environment\n...\n</code></pre>"},{"location":"usecases/argocd.html#override-namespaceresourceblacklist-andor-clusterresourcewhitelist-per-tenant","title":"Override NamespaceResourceBlacklist and/or ClusterResourceWhitelist per Tenant","text":"<p>Bill now wants a specific tenant to override the <code>namespaceResourceBlacklist</code> and/or <code>clusterResourceWhitelist</code> set via Integration Config. Bill will specify these in <code>argoCD.appProjects</code> section of Tenant spec.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: blue-sky\nspec:\nargocd:\nsourceRepos:\n# specify source repos here\n- \"https://github.com/stakater/GitOps-config\"\nappProject:\nclusterResourceWhitelist:\n- group: admissionregistration.k8s.io\nkind: validatingwebhookconfigurations\nnamespaceResourceBlacklist:\n- group: \"\"\nkind: ConfigMap\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nsandbox: false\nnamespaces:\nwithTenantPrefix:\n- build\n- stage\n</code></pre>"},{"location":"usecases/configuring-multitenant-network-isolation.html","title":"Configuring Multi-Tenant Isolation with Network Policy Template","text":"<p>Bill is a cluster admin who wants to configure network policies to provide multi-tenant network isolation.</p> <p>First, Bill creates a template for network policies:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: tenant-network-policy\nresources:\nmanifests:\n- apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-same-namespace\nspec:\npodSelector: {}\ningress:\n- from:\n- podSelector: {}\n- apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-from-openshift-monitoring\nspec:\ningress:\n- from:\n- namespaceSelector:\nmatchLabels:\nnetwork.openshift.io/policy-group: monitoring\npodSelector: {}\npolicyTypes:\n- Ingress\n- apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-from-openshift-ingress\nspec:\ningress:\n- from:\n- namespaceSelector:\nmatchLabels:\nnetwork.openshift.io/policy-group: ingress\npodSelector: {}\npolicyTypes:\n- Ingress\n</code></pre> <p>Once the template has been created, Bill edits the IntegrationConfig to add unique label to all tenant projects:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nproject:\nlabels:\nstakater.com/workload-monitoring: \"true\"\ntenant-network-policy: \"true\"\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\nsandbox:\nlabels:\nstakater.com/kind: sandbox\nprivilegedNamespaces:\n- default\n- ^openshift-*\n- ^kube-*\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift-*\n- ^system:serviceaccount:kube-*\n</code></pre> <p>Bill has added a new label <code>tenant-network-policy: \"true\"</code> in project section of IntegrationConfig, now MTO will add that label in all tenant projects.</p> <p>Finally Bill creates a <code>TemplateGroupInstance</code> which will distribute the network policies using the newly added project label and template.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: tenant-network-policy-group\nspec:\ntemplate: tenant-network-policy\nselector:\nmatchLabels:\ntenant-network-policy: \"true\"\nsync: true\n</code></pre> <p>MTO will now deploy the network policies mentioned in <code>Template</code> to all projects matching the label selector mentioned in the TemplateGroupInstance.</p>"},{"location":"usecases/custom-roles.html","title":"Changing the default access level for tenant owners","text":"<p>This feature allows the cluster admins to change the default roles assigned to Tenant owner, editor, viewer groups.</p> <p>For example, if Bill as the cluster admin wants to reduce the privileges that tenant owners have, so they cannot create or edit Roles or bind them. As an admin of an OpenShift cluster, Bill can do this by assigning the <code>edit</code> role to all tenant owners. This is easily achieved by modifying the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\ntenantRoles:\ndefault:\nowner:\nclusterRoles:\n- edit\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\n</code></pre> <p>Once all namespaces reconcile, the old <code>admin</code> RoleBindings should get replaced with the <code>edit</code> ones for each tenant owner.</p>"},{"location":"usecases/custom-roles.html#giving-specific-permissions-to-some-tenants","title":"Giving specific permissions to some tenants","text":"<p>Bill now wants the owners of the tenants <code>bluesky</code> and <code>alpha</code> to have <code>admin</code> permissions over their namespaces. Custom roles feature will allow Bill to do this, by modifying the IntegrationConfig like this:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\ntenantRoles:\ndefault:\nowner:\nclusterRoles:\n- edit\neditor:\nclusterRoles:\n- edit\nviewer:\nclusterRoles:\n- view\ncustom:\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\nowner:\nclusterRoles:\n- admin\n- labelSelector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- bluesky\nowner:\nclusterRoles:\n- admin\n</code></pre> <p>New Bindings will be created for the Tenant owners of <code>bluesky</code> and <code>alpha</code>, corresponding to the <code>admin</code> Role. Bindings for editors and viewer will be inherited from the <code>default roles</code>. All other Tenant owners will have an <code>edit</code> Role bound to them within their namespaces</p>"},{"location":"usecases/deploying-templates.html","title":"Distributing Resources in Namespaces","text":"<p>Multi Tenant Operator has three Custom Resources which can cover this need using the <code>Template</code> CR, depending upon the conditions and preference.</p> <ol> <li>TemplateGroupInstance</li> <li>TemplateInstance</li> <li>Tenant</li> </ol> <p>Stakater Team, however, encourages the use of <code>TemplateGroupInstance</code> to distribute resources in multiple namespaces as it is optimized for better performance.</p>"},{"location":"usecases/deploying-templates.html#deploying-template-to-namespaces-via-templategroupinstances","title":"Deploying Template to Namespaces via TemplateGroupInstances","text":"<p>Bill, the cluster admin, wants to deploy a docker pull secret in namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Bill makes a <code>TemplateGroupInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchLabels:\nkind: build\nsync: true\n</code></pre> <p>Afterwards, Bill can see that secrets have been successfully created in all label matching namespaces.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   3m\n\nkubectl get secret docker-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   2m\n</code></pre> <p><code>TemplateGroupInstance</code> can also target specific tenants or all tenant namespaces under a single yaml definition.</p>"},{"location":"usecases/deploying-templates.html#templategroupinstance-for-multiple-tenants","title":"TemplateGroupInstance for multiple Tenants","text":"<p>It can be done by using the <code>matchExpressions</code> field, dividing the tenant label in key and values.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\n- beta\nsync: true\n</code></pre>"},{"location":"usecases/deploying-templates.html#templategroupinstance-for-all-tenants","title":"TemplateGroupInstance for all Tenants","text":"<p>This can also be done by using the <code>matchExpressions</code> field, using just the tenant label key <code>stakater.com/tenant</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: Exists\nsync: true\n</code></pre>"},{"location":"usecases/deploying-templates.html#deploying-template-to-namespaces-via-tenant","title":"Deploying Template to Namespaces via Tenant","text":"<p>Bill is a cluster admin who wants to deploy a docker-pull-secret in Anna's tenant namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Bill edits Anna's tenant and populates the <code>namespacetemplate</code> field:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\neditors:\nusers:\n- john@aurora.org\nquota: small\nsandboxConfig:\nenabled: true\ntemplateInstances:\n- spec:\ntemplate: docker-pull-secret\nselector:\nmatchLabels:\nkind: build\n</code></pre> <p>Multi Tenant Operator will deploy <code>TemplateInstances</code> mentioned in <code>templateInstances</code> field, <code>TemplateInstances</code> will only be applied in those <code>namespaces</code> which belong to Anna's <code>tenant</code> and have the matching label of <code>kind: build</code>.</p> <p>So now Anna adds label <code>kind: build</code> to her existing namespace <code>bluesky-anna-aurora-sandbox</code>, and after adding the label she see's that the secret has been created.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME                  STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"usecases/deploying-templates.html#deploying-template-to-a-namespace-via-templateinstance","title":"Deploying Template to a Namespace via TemplateInstance","text":"<p>Anna wants to deploy a docker pull secret in her namespace.</p> <p>First Anna asks Bill, the cluster admin, to create a template of the secret for her:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Anna creates a <code>TemplateInstance</code> in her namespace referring to the <code>Template</code> she wants to deploy:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: docker-pull-secret-instance\nnamespace: bluesky-anna-aurora-sandbox\nspec:\ntemplate: docker-pull-secret\nsync: true\n</code></pre> <p>Once this is created, Anna can see that the secret has been successfully applied.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME                  STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"usecases/deploying-templates.html#passing-parameters-to-template-via-templateinstance-templategroupinstance-or-tenant","title":"Passing Parameters to Template via TemplateInstance, TemplateGroupInstance or Tenant","text":"<p>Anna wants to deploy a LimitRange resource to certain namespaces.</p> <p>First Anna asks Bill, the cluster admin, to create template with parameters for LimitRange for her:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: namespace-parameterized-restrictions\nparameters:\n# Name of the parameter\n- name: DEFAULT_CPU_LIMIT\n# The default value of the parameter\nvalue: \"1\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"0.5\"\n# If a parameter is required the template instance will need to set it\n# required: true\n# Make sure only values are entered for this parameter\nvalidation: \"^[0-9]*\\\\.?[0-9]+$\"\nresources:\nmanifests:\n- apiVersion: v1\nkind: LimitRange\nmetadata:\nname: namespace-limit-range-${namespace}\nspec:\nlimits:\n- default:\ncpu: \"${{DEFAULT_CPU_LIMIT}}\"\ndefaultRequest:\ncpu: \"${{DEFAULT_CPU_REQUESTS}}\"\ntype: Container\n</code></pre> <p>Afterwards, Anna creates a <code>TemplateInstance</code> in her namespace referring to the <code>Template</code> she wants to deploy:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: namespace-parameterized-restrictions-instance\nnamespace: bluesky-anna-aurora-sandbox\nspec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nparameters:\n- name: DEFAULT_CPU_LIMIT\nvalue: \"1.5\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"1\"\n</code></pre> <p>If she wants to distribute the same Template over multiple namespaces, she can use <code>TemplateGroupInstance</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: namespace-parameterized-restrictions-tgi\nspec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nselector:\nmatchExpressions:\n- key: stakater.com/tenant\noperator: In\nvalues:\n- alpha\n- beta\nparameters:\n- name: DEFAULT_CPU_LIMIT\nvalue: \"1.5\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"1\"\n</code></pre> <p>Or she can use her tenant to cover only the tenant namespaces.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\neditors:\nusers:\n- john@aurora.org\nquota: small\nsandboxConfig:\nenabled: true\ntemplateInstances:\n- spec:\ntemplate: namespace-parameterized-restrictions\nsync: true\nparameters:\n- name: DEFAULT_CPU_LIMIT\nvalue: \"1.5\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"1\"\nselector:\nmatchLabels:\nkind: build\n</code></pre>"},{"location":"usecases/distributing-resources.html","title":"Copying Secrets and Configmaps across Tenant Namespaces via TGI","text":"<p>Bill is a cluster admin who wants to map a <code>docker-pull-secret</code>, present in a <code>build</code> namespace, in tenant namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nresourceMappings:\nsecrets:\n- name: docker-pull-secret\nnamespace: build\n</code></pre> <p>Once the template has been created, Bill makes a <code>TemplateGroupInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: docker-secret-group-instance\nspec:\ntemplate: docker-pull-secret\nselector:\nmatchLabels:\nkind: build\nsync: true\n</code></pre> <p>Afterwards, Bill can see that secrets has been successfully mapped in all matching namespaces.</p> <pre><code>kubectl get secret docker-pull-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n\nkubectl get secret docker-pull-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"usecases/distributing-resources.html#mapping-resources-within-tenant-namespaces-via-ti","title":"Mapping Resources within Tenant Namespaces via TI","text":"<p>Anna is a tenant owner who wants to map a <code>docker-pull-secret</code>, present in <code>bluseky-build</code> namespace, to <code>bluesky-anna-aurora-sandbox</code> namespace.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nresourceMappings:\nsecrets:\n- name: docker-pull-secret\nnamespace: bluesky-build\n</code></pre> <p>Once the template has been created, Anna creates a <code>TemplateInstance</code> in <code>bluesky-anna-aurora-sandbox</code> namespace, referring to the <code>Template</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\nname: docker-secret-instance\nnamespace: bluesky-anna-aurora-sandbox\nspec:\ntemplate: docker-pull-secret\nsync: true\n</code></pre> <p>Afterwards, Bill can see that secrets has been successfully mapped in all matching namespaces.</p> <pre><code>kubectl get secret docker-pull-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"usecases/distributing-secrets-using-sealed-secret-template.html","title":"Distributing Secrets Using Sealed Secrets Template","text":"<p>Bill is a cluster admin who wants to provide a mechanism for distributing secrets in multiple namespaces. For this, he wants to use Sealed Secrets as the solution by adding them to MTO Template CR</p> <p>First, Bill creates a Template in which Sealed Secret is mentioned:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: tenant-sealed-secret\nresources:\nmanifests:\n- kind: SealedSecret\napiVersion: bitnami.com/v1alpha1\nmetadata:\nname: mysecret\nspec:\nencryptedData:\n.dockerconfigjson: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\ntemplate:\ntype: kubernetes.io/dockerconfigjson\n# this is an example of labels and annotations that will be added to the output secret\nmetadata:\nlabels:\n\"jenkins.io/credentials-type\": usernamePassword\nannotations:\n\"jenkins.io/credentials-description\": credentials from Kubernetes\n</code></pre> <p>Once the template has been created, Bill has to edit the <code>Tenant</code> to add unique label to namespaces in which the secret has to be deployed. For this, he can use the support for common and specific labels across namespaces.</p> <p>Bill has to specify a label on namespaces in which he needs the secret. He can add it to all namespaces inside a tenant or some specific namespaces depending on the use case.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\n\n# use this if you want to add label to some specific namespaces\nspecificMetadata:\n- namespaces:\n- test-namespace\nlabels:\ndistribute-image-pull-secret: true\n\n# use this if you want to add label to all namespaces under your tenant\ncommonMetadata:\nlabels:\ndistribute-image-pull-secret: true\n</code></pre> <p>Bill has added support for a new label <code>distribute-image-pull-secret: true\"</code> for tenant projects/namespaces, now MTO will add that label depending on the used field.</p> <p>Finally Bill creates a <code>TemplateGroupInstance</code> which will deploy the sealed secrets using the newly created project label and template.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: tenant-sealed-secret\nspec:\ntemplate: tenant-sealed-secret\nselector:\nmatchLabels:\ndistribute-image-pull-secret: true\nsync: true\n</code></pre> <p>MTO will now deploy the sealed secrets mentioned in <code>Template</code> to namespaces which have the mentioned label. The rest of the work to deploy secret from a sealed secret has to be done by Sealed Secrets Controller.</p>"},{"location":"usecases/extend-default-roles.html","title":"Extending the default access level for tenant members","text":"<p>Bill as the cluster admin wants to extend the default access for tenant members. As an admin of an OpenShift Cluster, Bill can extend the admin, edit, and view ClusterRole using aggregation. Bill will first create a ClusterRole with privileges to resources which Bill wants to extend. Bill will add the aggregation label to the newly created ClusterRole for extending the default ClusterRoles provided by OpenShift.</p> <pre><code>kind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: extend-view-role\nlabels:\nrbac.authorization.k8s.io/aggregate-to-view: 'true'\nrules:\n- verbs:\n- get\n- list\n- watch\napiGroups:\n- user.openshift.io\nresources:\n- groups\n</code></pre> <p>Note: You can learn more about <code>aggregated-cluster-roles</code> here</p>"},{"location":"usecases/hibernation.html","title":"Freeing up unused resources with hibernation","text":""},{"location":"usecases/hibernation.html#hibernating-a-tenant","title":"Hibernating a tenant","text":"<p>Bill is a cluster administrator who wants to free up unused cluster resources at nighttime, in an effort to reduce costs (when the cluster isn't being used).</p> <p>First, Bill creates a tenant with the <code>hibernation</code> schedules mentioned in the spec, or adds the hibernation field to an existing tenant:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nspec:\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nnamespaces:\nwithoutTenantPrefix:\n- build\n- stage\n- dev\n</code></pre> <p>The schedules above will put all the <code>Deployments</code> and <code>StatefulSets</code> within the tenant's namespaces to sleep, by reducing their pod count to 0 at 8 PM every weekday. At 8 AM on weekdays, the namespaces will then wake up by restoring their applications' previous pod counts.</p> <p>Bill can verify this behaviour by checking the newly created ResourceSupervisor resource at run time:</p> <pre><code>oc get ResourceSupervisor -A\nNAME           AGE\nsigma          5m\n</code></pre> <p>The ResourceSupervisor will look like this at 'running' time (as per the schedule):</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: example\nspec:\nargocd:\nappProjects: []\nnamespace: ''\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- build\n- stage\n- dev\nstatus:\ncurrentStatus: running\nnextReconcileTime: '2022-10-12T20:00:00Z'\n</code></pre> <p>The ResourceSupervisor will look like this at 'sleeping' time (as per the schedule):</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: example\nspec:\nargocd:\nappProjects: []\nnamespace: ''\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- build\n- stage\n- dev\nstatus:\ncurrentStatus: sleeping\nnextReconcileTime: '2022-10-13T08:00:00Z'\nsleepingApplications:\n- Namespace: build\nkind: Deployment\nname: example\nreplicas: 3\n- Namespace: stage\nkind: Deployment\nname: example\nreplicas: 3\n</code></pre> <p>Bill wants to prevent the <code>build</code> namespace from going to sleep, so he can add the <code>hibernation.stakater.com/exclude: 'true'</code> annotation to it. The ResourceSupervisor will now look like this after reconciling:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: example\nspec:\nargocd:\nappProjects: []\nnamespace: ''\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- stage\n- dev\nstatus:\ncurrentStatus: sleeping\nnextReconcileTime: '2022-10-13T08:00:00Z'\nsleepingApplications:\n- Namespace: stage\nkind: Deployment\nname: example\nreplicas: 3\n</code></pre>"},{"location":"usecases/hibernation.html#hibernating-namespaces-andor-argocd-applications-with-resourcesupervisor","title":"Hibernating namespaces and/or ArgoCD Applications with ResourceSupervisor","text":"<p>Bill, the cluster administrator, wants to hibernate a collection of namespaces and AppProjects belonging to multiple different tenants. He can do so by creating a ResourceSupervisor manually, specifying the hibernation schedule in its spec, the namespaces and ArgoCD Applications that need to be hibernated as per the mentioned schedule. Bill can also use the same method to hibernate some namespaces and ArgoCD Applications that do not belong to any tenant on his cluster.</p> <p>The example given below will hibernate the ArgoCD Applications in the 'test-app-project' AppProject; and it will also hibernate the 'ns2' and 'ns4' namespaces.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta1\nkind: ResourceSupervisor\nmetadata:\nname: test-resource-supervisor\nspec:\nargocd:\nappProjects:\n- test-app-project\nnamespace: argocd-ns\nhibernation:\nsleepSchedule: 0 20 * * 1-5\nwakeSchedule: 0 8 * * 1-5\nnamespaces:\n- ns2\n- ns4\nstatus:\ncurrentStatus: sleeping\nnextReconcileTime: '2022-10-13T08:00:00Z'\nsleepingApplications:\n- Namespace: ns2\nkind: Deployment\nname: test-deployment\nreplicas: 3\n</code></pre>"},{"location":"usecases/integrationconfig.html","title":"Configuring Managed Namespaces and ServiceAccounts in IntegrationConfig","text":"<p>Bill is a cluster admin who can use <code>IntegrationConfig</code> to configure how <code>Multi Tenant Operator (MTO)</code> manages the cluster.</p> <p>By default, MTO watches all namespaces and will enforce all the governing policies on them. All namespaces managed by MTO require the <code>stakater.com/tenant</code> label. MTO ignores privileged namespaces that are mentioned in the IntegrationConfig, and does not manage them. Therefore, any tenant label on such namespaces will be ignored.</p> <pre><code>oc create namespace stakater-test\nError from server (Cannot Create namespace stakater-test without label stakater.com/tenant. User: Bill): admission webhook \"vnamespace.kb.io\" denied the request: Cannot CREATE namespace stakater-test without label stakater.com/tenant. User: Bill\n</code></pre> <p>Bill is trying to create a namespace without the <code>stakater.com/tenant</code> label. Creating a namespace without this label is only allowed if the namespace is privileged. Privileged namespaces will be ignored by MTO and do not require the said label. Therefore, Bill will add the required regex in the IntegrationConfig, along with any other namespaces which are privileged and should be ignored by MTO - like <code>default</code>, or namespaces with prefixes like <code>openshift</code>, <code>kube</code>:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nprivilegedNamespaces:\n- ^default$\n- ^openshift*\n- ^kube*\n- ^stakater*\n</code></pre> <p>After mentioning the required regex (<code>^stakater*</code>) under <code>privilegedNamespaces</code>, Bill can create the namespace without interference.</p> <pre><code>oc create namespace stakater-test\nnamespace/stakater-test created\n</code></pre> <p>MTO will also disallow all users which are not tenant owners to perform CRUD operations on namespaces. This will also prevent Service Accounts from performing CRUD operations.</p> <p>If Bill wants MTO to ignore Service Accounts, then he would simply have to add them in the IntegrationConfig:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nprivilegedServiceAccounts:\n- system:serviceaccount:openshift\n- system:serviceaccount:stakater\n- system:serviceaccount:kube\n- system:serviceaccount:redhat\n- system:serviceaccount:hive\n</code></pre> <p>Bill can also use regex patterns to ignore a set of service accounts:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nopenshift:\nprivilegedServiceAccounts:\n- ^system:serviceaccount:openshift*\n- ^system:serviceaccount:stakater*\n</code></pre>"},{"location":"usecases/integrationconfig.html#configuring-vault-in-integrationconfig","title":"Configuring Vault in IntegrationConfig","text":"<p>Vault is used to secure, store and tightly control access to tokens, passwords, certificates, and encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.</p> <p>If Bill (the cluster admin) has Vault configured in his cluster, then he can take benefit from MTO's integration with Vault.</p> <p>MTO automatically creates Vault secret paths for tenants, where tenant members can securely save their secrets. It also authorizes tenant members to access these secrets via OIDC.</p> <p>Bill would first have to integrate Vault with MTO by adding the details in IntegrationConfig. For more details</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: IntegrationConfig\nmetadata:\nname: tenant-operator-config\nnamespace: stakater-tenant-operator\nspec:\nvault:\nenabled: true\nendpoint:\nsecretReference:\nname: vault-root-token\nnamespace: vault\nurl: &gt;-\nhttps://vault.apps.prod.abcdefghi.kubeapp.cloud/\nsso:\naccessorID: auth_oidc_aa6aa9aa\nclientName: vault\n</code></pre> <p>Bill then creates a tenant for Anna and John:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@acme.org\nviewers:\nusers:\n- john@acme.org\nquota: small\nsandbox: false\n</code></pre> <p>Now Bill goes to <code>Vault</code> and sees that a path for <code>tenant</code> has been made under the name <code>bluesky/kv</code>, confirming that Tenant members with the Owner or Edit roles now have access to the tenant's Vault path.</p> <p>Now if Anna sign's in to the Vault via OIDC, she can see her tenants path and secrets. Whereas if John sign's in to the Vault via OIDC, he can't see his tenants path or secrets as he doesn't have the access required to view them.</p>"},{"location":"usecases/integrationconfig.html#configuring-rhsso-red-hat-single-sign-on-in-integrationconfig","title":"Configuring RHSSO (Red Hat Single Sign-On) in IntegrationConfig","text":"<p>Red Hat Single Sign-On RHSSO is based on the Keycloak project and enables you to secure your web applications by providing Web single sign-on (SSO) capabilities based on popular standards such as SAML 2.0, OpenID Connect and OAuth 2.0.</p> <p>If Bill the cluster admin has RHSSO configured in his cluster, then he can take benefit from MTO's integration with RHSSO and Vault.</p> <p>MTO automatically allows tenant members to access Vault via OIDC(RHSSO authentication and authorization) to access secret paths for tenants where tenant members can securely save their secrets.</p> <p>Bill would first have to integrate RHSSO with MTO by adding the details in IntegrationConfig. Visit here for more details.</p> <pre><code>rhsso:\nenabled: true\nrealm: customer\nendpoint:\nsecretReference:\nname: auth-secrets\nnamespace: openshift-auth\nurl: https://iam-keycloak-auth.apps.prod.abcdefghi.kubeapp.cloud/\n</code></pre>"},{"location":"usecases/mattermost.html","title":"Creating Mattermost Teams for your tenant","text":""},{"location":"usecases/mattermost.html#requirements","title":"Requirements","text":"<p><code>MTO-Mattermost-Integration-Operator</code></p> <p>Please contact stakater to install the Mattermost integration operator before following the below mentioned steps.</p>"},{"location":"usecases/mattermost.html#steps-to-enable-integration","title":"Steps to enable integration","text":"<p>Bill wants some of the tenants to also have their own Mattermost Teams. To make sure this happens correctly, Bill will first add the <code>stakater.com/mattermost: true</code> label to the tenants. The label will enable the <code>mto-mattermost-integration-operator</code> to create and manage Mattermost Teams based on Tenants.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nlabels:\nstakater.com/mattermost: 'true'\nspec:\nowners:\nusers:\n- user\neditors:\nusers:\n- user1\nquota: medium\nsandbox: false\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\n</code></pre> <p>Now user can logIn to Mattermost to see their Team and relevant channels associated with it.</p> <p></p> <p>The name of the Team is similar to the Tenant name. Notification channels are pre-configured for every team, and can be modified.</p>"},{"location":"usecases/namespace.html","title":"Creating Namespace","text":"<p>Anna as the tenant owner can create new namespaces for her tenant.</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: bluesky-production\nlabels:\nstakater.com/tenant: bluesky\n</code></pre> <p>\u26a0\ufe0f Anna is required to add the tenant label <code>stakater.com/tenant: bluesky</code> which contains the name of her tenant <code>bluesky</code>, while creating the namespace. If this label is not added or if Anna does not belong to the <code>bluesky</code> tenant, then Multi Tenant Operator will not allow the creation of that namespace.</p> <p>When Anna creates the namespace, MTO assigns Anna and other tenant members the roles based on their user types, such as a tenant owner getting the OpenShift <code>admin</code> role for that namespace.</p> <p>As a tenant owner, Anna is able to create namespaces.</p> <p>If you have enabled ArgoCD Multitenancy, our preferred solution is to create tenant namespaces by using Tenant spec to avoid syncing issues in ArgoCD console during namespace creation.</p>"},{"location":"usecases/namespace.html#add-existing-namespaces-to-tenant-via-gitops","title":"Add Existing Namespaces to Tenant via GitOps","text":"<p>Using GitOps as your preferred development workflow, you can add existing namespaces for your tenants by including the tenant label.</p> <p>To add an existing namespace to your tenant via GitOps:</p> <ol> <li>First, migrate your namespace resource to your \u201cwatched\u201d git repository</li> <li>Edit your namespace <code>yaml</code> to include the tenant label</li> <li>Tenant label follows the naming convention <code>stakater.com/tenant: &lt;TENANT_NAME&gt;</code></li> <li>Sync your GitOps repository with your cluster and allow changes to be propagated</li> <li>Verify that your Tenant users now have access to the namespace</li> </ol> <p>For example, If Anna, a tenant owner, wants to add the namespace <code>bluesky-dev</code> to her tenant via GitOps, after migrating her namespace manifest to a \u201cwatched repository\u201d</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: bluesky-dev\n</code></pre> <p>She can then add the tenant label</p> <pre><code> ...\nlabels:\nstakater.com/tenant: bluesky\n</code></pre> <p>Now all the users of the <code>Bluesky</code> tenant now have access to the existing namespace.</p> <p>Additionally, to remove namespaces from a tenant, simply remove the tenant label from the namespace resource and sync your changes to your cluster.</p>"},{"location":"usecases/namespace.html#remove-namespaces-from-your-cluster-via-gitops","title":"Remove Namespaces from your Cluster via GitOps","text":"<p>GitOps is a quick and efficient way to automate the management of your K8s resources.</p> <p>To remove namespaces from your cluster via GitOps;</p> <ul> <li>Remove the <code>yaml</code> file containing your namespace configurations from your \u201cwatched\u201d git repository.</li> <li>ArgoCD automatically sets the <code>[app.kubernetes.io/instance](http://app.kubernetes.io/instance)</code> label on resources it manages. It uses this label it to select resources which inform the basis of an app. To remove a namespace from a managed ArgoCD app, remove the ArgoCD label <code>app.kubernetes.io/instance</code> from the namespace manifest.</li> <li>You can edit your namespace manifest through the OpenShift Web Console or with the OpenShift command line tool.</li> <li>Now that you have removed your namespace manifest from your watched git repository, and from your managed ArgoCD apps, sync your git repository and allow your changes be propagated.</li> <li>Verify that your namespace has been deleted.</li> </ul>"},{"location":"usecases/private-sandboxes.html","title":"Create Private Sandboxes","text":"<p>Bill assigned the ownership of <code>bluesky</code> to <code>Anna</code> and <code>Anthony</code>. Now if the users want sandboxes to be made for them, they'll have to ask <code>Bill</code> to enable <code>sandbox</code> functionality. The Users also want to make sure that the sandboxes that are created for them are also only visible to the user they belong to. To enable that, Bill will just set <code>enabled: true</code> and <code>private: true</code> within the <code>sandboxConfig</code> field</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandboxConfig:\nenabled: true\nprivate: true\nEOF\n</code></pre> <p>With the above configuration <code>Anna</code> and <code>Anthony</code> will now have new sandboxes created</p> <pre><code>kubectl get namespaces\nNAME                             STATUS   AGE\nbluesky-anna-aurora-sandbox      Active   5d5h\nbluesky-anthony-aurora-sandbox   Active   5d5h\nbluesky-john-aurora-sandbox      Active   5d5h\n</code></pre> <p>However, from the perspective of <code>Anna</code>, only their sandbox will be visible</p> <pre><code>kubectl get namespaces\nNAME                             STATUS   AGE\nbluesky-anna-aurora-sandbox      Active   5d5h\n</code></pre>"},{"location":"usecases/quota.html","title":"Enforcing Quotas","text":"<p>Using Multi Tenant Operator, the cluster-admin can set and enforce cluster resource quotas and limit ranges for tenants.</p>"},{"location":"usecases/quota.html#assigning-resource-quotas","title":"Assigning Resource Quotas","text":"<p>Bill is a cluster admin who will first create <code>Quota</code> CR where he sets the maximum resource limits that Anna's tenant will have. Here <code>limitrange</code> is an optional field, cluster admin can skip it if not needed.</p> <p>The annotation <code>quota.tenantoperator.stakater.com/is-default: \"true\"</code> sets the quota as default quota.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nannotations:\nquota.tenantoperator.stakater.com/is-default: \"false\"\nname: small\nspec:\nresourcequota:\nhard:\nrequests.cpu: '5'\nrequests.memory: '5Gi'\nconfigmaps: \"10\"\nsecrets: \"10\"\nservices: \"10\"\nservices.loadbalancers: \"2\"\nlimitrange:\nlimits:\n- type: \"Pod\"\nmax:\ncpu: \"2\"\nmemory: \"1Gi\"\nmin:\ncpu: \"200m\"\nmemory: \"100Mi\"\nEOF\n</code></pre> <p>For more details please refer to Quotas.</p> <pre><code>kubectl get quota small\nNAME       STATE    AGE\nsmall      Active   3m\n</code></pre> <p>Bill then proceeds to create a tenant for Anna, while also linking the newly created <code>Quota</code>.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@stakater.com\nquota: small\nsandbox: false\nEOF\n</code></pre> <p>When no quota is mentioned in the <code>quota</code> field of Tenant CR, MTO looks for quota with the following annotation <code>quota.tenantoperator.stakater.com/is-default: \"true\"</code> and links that quota with the tenant.</p> <p>Now that the quota is linked with Anna's tenant, Anna can create any resource within the values of resource quota and limit range.</p> <pre><code>kubectl -n bluesky-production create deployment nginx --image nginx:latest --replicas 4\n</code></pre> <p>Once the resource quota assigned to the tenant has been reached, Anna cannot create further resources.</p> <pre><code>kubectl create pods bluesky-training\nError from server (Cannot exceed Namespace quota: please, reach out to the system administrators)\n</code></pre>"},{"location":"usecases/secret-distribution.html","title":"Propagate Secrets from Parent to Descendant namespaces","text":"<p>Secrets like <code>registry</code> credentials often need to exist in multiple Namespaces, so that Pods within different namespaces can have access to those credentials in form of secrets.</p> <p>Manually creating secrets within different namespaces could lead to challenges, such as:</p> <ul> <li>Someone will have to create secret either manually or via GitOps each time there is a new descendant namespace that needs the secret</li> <li>If we update the parent secret, they will have to update the secret in all descendant namespaces</li> <li>This could be time-consuming, and a small mistake while creating or updating the secret could lead to unnecessary debugging</li> </ul> <p>With the help of Multi-Tenant Operator's Template feature we can make this secret distribution experience easy.</p> <p>For example, to copy a Secret called <code>registry</code> which exists in the <code>example</code> to new Namespaces whenever they are created, we will first create a Template which will have reference of the registry secret.</p> <p>It will also push updates to the copied Secrets and keep the propagated secrets always sync and updated with parent namespaces.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: registry-secret\nresources:\nresourceMappings:\nsecrets:\n- name: registry\nnamespace: example\n</code></pre> <p>Now using this Template we can propagate registry secret to different namespaces that has some common set of labels.</p> <p>For example, will just add one label <code>kind: registry</code> and all namespaces with this label will get this secret.</p> <p>For propagating it on different namespaces dynamically will have to create another resource called <code>TemplateGroupInstance</code>. <code>TemplateGroupInstance</code> will have <code>Template</code> and <code>matchLabel</code> mapping as shown below:</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: TemplateGroupInstance\nmetadata:\nname: registry-secret-group-instance\nspec:\ntemplate: registry-secret\nselector:\nmatchLabels:\nkind: registry\nsync: true\n</code></pre> <p>After reconciliation, you will be able to see those secrets in namespaces having mentioned label.</p> <p>MTO will keep injecting this secret to the new namespaces created with that label.</p> <pre><code>kubectl get secret registry-secret -n example-ns-1\nNAME             STATE    AGE\nregistry-secret    Active   3m\n\nkubectl get secret registry-secret -n example-ns-2\nNAME             STATE    AGE\nregistry-secret    Active   3m\n</code></pre>"},{"location":"usecases/template.html","title":"Creating Templates","text":"<p>Anna wants to create a Template that she can use to initialize or share common resources across namespaces (e.g. PullSecrets).</p> <p>Anna can either create a template using <code>manifests</code> field, covering Kubernetes or custom resources.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: docker-pull-secret\nresources:\nmanifests:\n- kind: Secret\napiVersion: v1\nmetadata:\nname: docker-pull-secret\ndata:\n.dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\ntype: kubernetes.io/dockercfg\n</code></pre> <p>Or by using <code>Helm Charts</code></p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: redis\nresources:\nhelm:\nreleaseName: redis\nchart:\nrepository:\nname: redis\nrepoUrl: https://charts.bitnami.com/bitnami\nvalues: |\nredisPort: 6379\n</code></pre> <p>She can also use <code>resourceMapping</code> field to copy over secrets and configmaps from one namespace to others.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: resource-mapping\nresources:\nresourceMappings:\nsecrets:\n- name: docker-secret\nnamespace: bluesky-build\nconfigMaps:\n- name: tronador-configMap\nnamespace: stakater-tronador\n</code></pre> <p>Note: Resource mapping can be used via TGI to map resources within tenant namespaces or to some other tenant's namespace. If used with TI, the resources will only be mapped if namespaces belong to same tenant.</p>"},{"location":"usecases/template.html#using-templates-with-default-parameters","title":"Using Templates with Default Parameters","text":"<pre><code>apiVersion: tenantoperator.stakater.com/v1alpha1\nkind: Template\nmetadata:\nname: namespace-parameterized-restrictions\nparameters:\n# Name of the parameter\n- name: DEFAULT_CPU_LIMIT\n# The default value of the parameter\nvalue: \"1\"\n- name: DEFAULT_CPU_REQUESTS\nvalue: \"0.5\"\n# If a parameter is required the template instance will need to set it\n# required: true\n# Make sure only values are entered for this parameter\nvalidation: \"^[0-9]*\\\\.?[0-9]+$\"\nresources:\nmanifests:\n- apiVersion: v1\nkind: LimitRange\nmetadata:\nname: namespace-limit-range-${namespace}\nspec:\nlimits:\n- default:\ncpu: \"${{DEFAULT_CPU_LIMIT}}\"\ndefaultRequest:\ncpu: \"${{DEFAULT_CPU_REQUESTS}}\"\ntype: Container\n</code></pre> <p>Parameters can be used with both <code>manifests</code> and <code>helm charts</code></p>"},{"location":"usecases/tenant.html","title":"Creating Tenant","text":"<p>Bill is a cluster admin who receives a new request from Aurora Solutions CTO asking for a new tenant for Anna's team.</p> <p>Bill creates a new tenant called <code>bluesky</code> in the cluster:</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandbox: false\nEOF\n</code></pre> <p>Bill checks if the new tenant is created:</p> <pre><code>kubectl get tenants.tenantoperator.stakater.com bluesky\nNAME       STATE    AGE\nbluesky    Active   3m\n</code></pre> <p>Anna can now login to the cluster and check if she can create namespaces</p> <pre><code>kubectl auth can-i create namespaces\nyes\n</code></pre> <p>However, cluster resources are not accessible to Anna</p> <pre><code>kubectl auth can-i get namespaces\nno\n\nkubectl auth can-i get persistentvolumes\nno\n</code></pre> <p>Including the <code>Tenant</code> resource</p> <pre><code>kubectl auth can-i get tenants.tenantoperator.stakater.com\nno\n</code></pre>"},{"location":"usecases/tenant.html#assign-multiple-users-as-tenant-owner","title":"Assign multiple users as tenant owner","text":"<p>In the example above, Bill assigned the ownership of <code>bluesky</code> to <code>Anna</code>. If another user, e.g. <code>Anthony</code> needs to administer <code>bluesky</code>, than Bill can assign the ownership of tenant to that user as well:</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandbox: false\nEOF\n</code></pre> <p>With the configuration above, Anthony can log-in to the cluster and execute</p> <pre><code>kubectl auth can-i create namespaces\nyes\n</code></pre>"},{"location":"usecases/tenant.html#assigning-users-sandbox-namespace","title":"Assigning Users Sandbox Namespace","text":"<p>Bill assigned the ownership of <code>bluesky</code> to <code>Anna</code> and <code>Anthony</code>. Now if the users want sandboxes to be made for them, they'll have to ask <code>Bill</code> to enable <code>sandbox</code> functionality.</p> <p>To enable that, Bill will just set <code>enabled: true</code> within the <code>sandboxConfig</code> field</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandboxConfig:\nenabled: true\nEOF\n</code></pre> <p>With the above configuration <code>Anna</code> and <code>Anthony</code> will now have new sandboxes created</p> <pre><code>kubectl get namespaces\nNAME                             STATUS   AGE\nbluesky-anna-aurora-sandbox      Active   5d5h\nbluesky-anthony-aurora-sandbox   Active   5d5h\nbluesky-john-aurora-sandbox      Active   5d5h\n</code></pre> <p>If Bill wants to make sure that only the sandbox owner can view his sandbox namespace, he can achieve this by setting <code>private: true</code> within the <code>sandboxConfig</code> filed.</p>"},{"location":"usecases/tenant.html#creating-namespaces-via-tenant-custom-resource","title":"Creating Namespaces via Tenant Custom Resource","text":"<p>Bill now wants to create namespaces for <code>dev</code>, <code>build</code> and <code>production</code> environments for the tenant members. To create those namespaces Bill will just add those names within the <code>namespaces</code> field in the tenant CR. If Bill wants to append the tenant name as a prefix in namespace name, then he can use <code>namespaces.withTenantPrefix</code> field. Else he can use <code>namespaces.withoutTenantPrefix</code> for namespaces for which he does not need tenant name as a prefix.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\nwithoutTenantPrefix:\n- prod\nEOF\n</code></pre> <p>With the above configuration tenant members will now see new namespaces have been created.</p> <pre><code>kubectl get namespaces\nNAME             STATUS   AGE\nbluesky-dev      Active   5d5h\nbluesky-build    Active   5d5h\nprod             Active   5d5h\n</code></pre>"},{"location":"usecases/tenant.html#distributing-common-labels-and-annotations-to-tenant-namespaces-via-tenant-custom-resource","title":"Distributing common labels and annotations to tenant namespaces via Tenant Custom Resource","text":"<p>Bill now wants to add labels/annotations to all the namespaces for a tenant. To create those labels/annotations Bill will just add them into <code>commonMetadata.labels</code>/<code>commonMetadata.annotations</code> field in the tenant CR.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\ncommonMetadata:\nlabels:\napp.kubernetes.io/managed-by: tenant-operator\napp.kubernetes.io/part-of: tenant-alpha\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/infra=\nEOF\n</code></pre> <p>With the above configuration all tenant namespaces will now contain the mentioned labels and annotations.</p>"},{"location":"usecases/tenant.html#distributing-specific-labels-and-annotations-to-tenant-namespaces-via-tenant-custom-resource","title":"Distributing specific labels and annotations to tenant namespaces via Tenant Custom Resource","text":"<p>Bill now wants to add labels/annotations to specific namespaces for a tenant. To create those labels/annotations Bill will just add them into <code>specificMetadata.labels</code>/<code>specificMetadata.annotations</code> and specific namespaces in <code>specificMetadata.namespaces</code> field in the tenant CR.</p> <pre><code>kubectl apply -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\neditors:\nusers:\n- john@aurora.org\ngroups:\n- alpha\nquota: small\nsandboxConfig:\nenabled: true\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\nspecificMetadata:\n- namespaces:\n- bluesky-anna-aurora-sandbox\nlabels:\napp.kubernetes.io/is-sandbox: true\nannotations:\nopenshift.io/node-selector: node-role.kubernetes.io/worker=\nEOF\n</code></pre> <p>With the above configuration all tenant namespaces will now contain the mentioned labels and annotations.</p>"},{"location":"usecases/tenant.html#retaining-tenant-namespaces-and-appproject-when-a-tenant-is-being-deleted","title":"Retaining tenant namespaces and AppProject when a tenant is being deleted","text":"<p>Bill now wants to delete tenant <code>bluesky</code> and wants to retain all namespaces and AppProject of the tenant. To retain the namespaces Bill will set <code>spec.onDelete.cleanNamespaces</code>, and <code>spec.onDelete.cleanAppProjects</code> to <code>false</code>.</p> <pre><code>apiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\nquota: small\nsandboxConfig:\nenabled: true\nnamespaces:\nwithTenantPrefix:\n- dev\n- build\n- prod\nonDelete:\ncleanNamespaces: false\ncleanAppProject: false\n</code></pre> <p>With the above configuration all tenant namespaces and AppProject will not be deleted when tenant <code>bluesky</code> is deleted. By default, the value of <code>spec.onDelete.cleanNamespaces</code> is also <code>false</code> and <code>spec.onDelete.cleanAppProject</code> is <code>true</code></p>"},{"location":"usecases/volume-limits.html","title":"Limiting PersistentVolume for Tenant","text":"<p>Bill, as a cluster admin, wants to restrict the amount of storage a Tenant can use. For that he'll add the <code>requests.storage</code> field to <code>quota.spec.resourcequota.hard</code>. If Bill wants to restrict tenant <code>bluesky</code> to use only <code>50Gi</code> of storage, he'll first create a quota with <code>requests.storage</code> field set to <code>50Gi</code>.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nname: medium\nspec:\nresourcequota:\nhard:\nrequests.cpu: '5'\nrequests.memory: '10Gi'\nrequests.storage: '50Gi'\n</code></pre> <p>Once the quota is created, Bill will create the tenant and set the quota field to the one he created.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: bluesky\nspec:\nowners:\nusers:\n- anna@aurora.org\n- anthony@aurora.org\nquota: medium\nsandbox: true\nEOF\n</code></pre> <p>Now, the combined storage used by all tenant namespaces will not exceed <code>50Gi</code>.</p>"},{"location":"usecases/volume-limits.html#adding-storageclass-restrictions-for-tenant","title":"Adding StorageClass Restrictions for Tenant","text":"<p>Now, Bill, as a cluster admin, wants to make sure that no Tenant can provision more than a fixed amount of storage from a StorageClass. Bill can restrict that using <code>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage</code> field in <code>quota.spec.resourcequota.hard</code> field. If Bill wants to restrict tenant <code>sigma</code> to use only <code>20Gi</code> of storage from storage class <code>stakater</code>, he'll first create a StorageClass <code>stakater</code> and then create the relevant Quota with <code>stakater.storageclass.storage.k8s.io/requests.storage</code> field set to <code>20Gi</code>.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta1\nkind: Quota\nmetadata:\nname: small\nspec:\nresourcequota:\nhard:\nrequests.cpu: '2'\nrequests.memory: '4Gi'\nstakater.storageclass.storage.k8s.io/requests.storage: '20Gi'\n</code></pre> <p>Once the quota is created, Bill will create the tenant and set the quota field to the one he created.</p> <pre><code>kubectl create -f - &lt;&lt; EOF\napiVersion: tenantoperator.stakater.com/v1beta2\nkind: Tenant\nmetadata:\nname: sigma\nspec:\nowners:\nusers:\n- dave@aurora.org\nquota: small\nsandbox: true\nEOF\n</code></pre> <p>Now, the combined storage provisioned from StorageClass <code>stakater</code> used by all tenant namespaces will not exceed <code>20Gi</code>.</p> <p>The <code>20Gi</code> limit will only be applied to StorageClass <code>stakater</code>. If a tenant member creates a PVC with some other StorageClass, he will not be restricted.</p> <p>Tip</p> <p>More details about <code>Resource Quota</code> can be found here</p>"}]}